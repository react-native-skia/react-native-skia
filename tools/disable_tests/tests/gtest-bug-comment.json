{
  "args": [
    "./disable",
    "-b",
    "1234567",
    "8802545798771106129",
    ".*BrowserViewTest.GetAccessibleTabModalDialogTree.*"
  ],
  "requests": "{\"QueryTestResults/{\\\"invocations\\\": [\\\"invocations/build-8802545798771106129\\\"], \\\"readMask\\\": {\\\"paths\\\": [\\\"test_id\\\", \\\"test_metadata\\\"]}, \\\"pageSize\\\": 1000, \\\"predicate\\\": {\\\"testIdRegexp\\\": \\\".*BrowserViewTest.GetAccessibleTabModalDialogTree.*\\\"}}\": \"{\\\"testResults\\\":[{\\\"name\\\":\\\"invocations/task-chromium-swarm.appspot.com-5d7161f0cd866211/tests/ninja:%2F%2Fchrome%2Ftest:browser_tests%2FBrowserViewTest.GetAccessibleTabModalDialogTree/results/0e419060-01374\\\",\\\"testId\\\":\\\"ninja://chrome/test:browser_tests/BrowserViewTest.GetAccessibleTabModalDialogTree\\\",\\\"testMetadata\\\":{\\\"name\\\":\\\"BrowserViewTest.GetAccessibleTabModalDialogTree\\\",\\\"location\\\":{\\\"repo\\\":\\\"https://chromium.googlesource.com/chromium/src\\\",\\\"fileName\\\":\\\"//chrome/browser/ui/views/frame/browser_view_browsertest.cc\\\",\\\"line\\\":359}}}]}\\n\"}",
  "read_data": {
    "chrome/browser/ui/views/frame/browser_view_browsertest.cc": "// Copyright 2013 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"chrome/browser/ui/views/frame/browser_view.h\"\n\n#include \"base/memory/raw_ptr.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"build/build_config.h\"\n#include \"build/chromeos_buildflags.h\"\n#include \"chrome/browser/devtools/devtools_window_testing.h\"\n#include \"chrome/browser/ui/browser.h\"\n#include \"chrome/browser/ui/browser_tabstrip.h\"\n#include \"chrome/browser/ui/tab_modal_confirm_dialog.h\"\n#include \"chrome/browser/ui/tab_ui_helper.h\"\n#include \"chrome/browser/ui/tabs/tab_strip_model.h\"\n#include \"chrome/browser/ui/views/bookmarks/bookmark_bar_view.h\"\n#include \"chrome/browser/ui/views/bookmarks/bookmark_bar_view_observer.h\"\n#include \"chrome/browser/ui/views/tabs/tab_strip.h\"\n#include \"chrome/common/pref_names.h\"\n#include \"chrome/common/url_constants.h\"\n#include \"chrome/grit/chromium_strings.h\"\n#include \"chrome/test/base/in_process_browser_test.h\"\n#include \"chrome/test/base/ui_test_utils.h\"\n#include \"components/bookmarks/common/bookmark_pref_names.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"content/public/browser/browser_accessibility_state.h\"\n#include \"content/public/browser/invalidate_type.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"content/public/test/browser_test.h\"\n#include \"content/public/test/browser_test_utils.h\"\n#include \"content/public/test/test_navigation_observer.h\"\n#include \"media/base/media_switches.h\"\n#include \"ui/accessibility/platform/ax_platform_node.h\"\n#include \"ui/accessibility/platform/ax_platform_node_test_helper.h\"\n#include \"ui/base/l10n/l10n_util.h\"\n\n#if defined(USE_AURA)\n#include \"ui/aura/client/focus_client.h\"\n#include \"ui/views/widget/native_widget_aura.h\"\n#endif  // USE_AURA\n\nclass BrowserViewTest : public InProcessBrowserTest {\n public:\n  BrowserViewTest() : devtools_(nullptr) {}\n\n  BrowserViewTest(const BrowserViewTest&) = delete;\n  BrowserViewTest& operator=(const BrowserViewTest&) = delete;\n\n protected:\n  BrowserView* browser_view() {\n    return BrowserView::GetBrowserViewForBrowser(browser());\n  }\n\n  views::WebView* devtools_web_view() {\n    return browser_view()->GetDevToolsWebViewForTest();\n  }\n\n  views::WebView* contents_web_view() {\n    return browser_view()->contents_web_view();\n  }\n\n  void OpenDevToolsWindow(bool docked) {\n    devtools_ =\n        DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), docked);\n  }\n\n  void CloseDevToolsWindow() {\n    DevToolsWindowTesting::CloseDevToolsWindowSync(devtools_);\n  }\n\n  void SetDevToolsBounds(const gfx::Rect& bounds) {\n    DevToolsWindowTesting::Get(devtools_)->SetInspectedPageBounds(bounds);\n  }\n\n  raw_ptr<DevToolsWindow> devtools_;\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\nnamespace {\n\n// Used to simulate scenario in a crash. When WebContentsDestroyed() is invoked\n// updates the navigation state of another tab.\nclass TestWebContentsObserver : public content::WebContentsObserver {\n public:\n  TestWebContentsObserver(content::WebContents* source,\n                          content::WebContents* other)\n      : content::WebContentsObserver(source),\n        other_(other) {}\n\n  TestWebContentsObserver(const TestWebContentsObserver&) = delete;\n  TestWebContentsObserver& operator=(const TestWebContentsObserver&) = delete;\n\n  ~TestWebContentsObserver() override {}\n\n  void WebContentsDestroyed() override {\n    other_->NotifyNavigationStateChanged(static_cast<content::InvalidateTypes>(\n        content::INVALIDATE_TYPE_URL | content::INVALIDATE_TYPE_LOAD));\n  }\n\n private:\n  raw_ptr<content::WebContents> other_;\n};\n\nclass TestTabModalConfirmDialogDelegate : public TabModalConfirmDialogDelegate {\n public:\n  explicit TestTabModalConfirmDialogDelegate(content::WebContents* contents)\n      : TabModalConfirmDialogDelegate(contents) {}\n\n  TestTabModalConfirmDialogDelegate(const TestTabModalConfirmDialogDelegate&) =\n      delete;\n  TestTabModalConfirmDialogDelegate& operator=(\n      const TestTabModalConfirmDialogDelegate&) = delete;\n\n  std::u16string GetTitle() override { return std::u16string(u\"Dialog Title\"); }\n  std::u16string GetDialogMessage() override { return std::u16string(); }\n};\n}  // namespace\n\n// Verifies don't crash when CloseNow() is invoked with two tabs in a browser.\n// Additionally when one of the tabs is destroyed NotifyNavigationStateChanged()\n// is invoked on the other.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, CloseWithTabs) {\n  Browser* browser2 =\n      Browser::Create(Browser::CreateParams(browser()->profile(), true));\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  TestWebContentsObserver observer(\n      browser2->tab_strip_model()->GetWebContentsAt(0),\n      browser2->tab_strip_model()->GetWebContentsAt(1));\n  BrowserView::GetBrowserViewForBrowser(browser2)->GetWidget()->CloseNow();\n}\n\n// Same as CloseWithTabs, but activates the first tab, which is the first tab\n// BrowserView will destroy.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, CloseWithTabsStartWithActive) {\n  Browser* browser2 =\n      Browser::Create(Browser::CreateParams(browser()->profile(), true));\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  browser2->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  TestWebContentsObserver observer(\n      browser2->tab_strip_model()->GetWebContentsAt(0),\n      browser2->tab_strip_model()->GetWebContentsAt(1));\n  BrowserView::GetBrowserViewForBrowser(browser2)->GetWidget()->CloseNow();\n}\n\n// Verifies that page and devtools WebViews are being correctly layed out\n// when DevTools is opened/closed/updated/undocked.\n// TODO(crbug.com/1316663): Re-enable; currently failing on multiple platforms.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, DISABLED_DevToolsUpdatesBrowserWindow) {\n  gfx::Rect full_bounds =\n      browser_view()->GetContentsContainerForTest()->GetLocalBounds();\n  gfx::Rect small_bounds(10, 20, 30, 40);\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  // Docked.\n  OpenDevToolsWindow(true);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n\n  SetDevToolsBounds(small_bounds);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  CloseDevToolsWindow();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  // Undocked.\n  OpenDevToolsWindow(false);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n\n  SetDevToolsBounds(small_bounds);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  CloseDevToolsWindow();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n}\n\nclass BookmarkBarViewObserverImpl : public BookmarkBarViewObserver {\n public:\n  BookmarkBarViewObserverImpl() : change_count_(0) {\n  }\n\n  BookmarkBarViewObserverImpl(const BookmarkBarViewObserverImpl&) = delete;\n  BookmarkBarViewObserverImpl& operator=(const BookmarkBarViewObserverImpl&) =\n      delete;\n\n  int change_count() const { return change_count_; }\n  void clear_change_count() { change_count_ = 0; }\n\n  // BookmarkBarViewObserver:\n  void OnBookmarkBarVisibilityChanged() override { change_count_++; }\n\n private:\n  int change_count_ = 0;\n};\n\n// Verifies we don't unnecessarily change the visibility of the BookmarkBarView.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, AvoidUnnecessaryVisibilityChanges) {\n  // Create two tabs, the first empty and the second the ntp. Make it so the\n  // BookmarkBarView isn't shown.\n  browser()->profile()->GetPrefs()->SetBoolean(\n      bookmarks::prefs::kShowBookmarkBar, false);\n  GURL new_tab_url(chrome::kChromeUINewTabURL);\n  chrome::AddTabAt(browser(), GURL(), -1, true);\n  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), new_tab_url));\n\n  ASSERT_TRUE(browser_view()->bookmark_bar());\n  BookmarkBarViewObserverImpl observer;\n  BookmarkBarView* bookmark_bar = browser_view()->bookmark_bar();\n  bookmark_bar->AddObserver(&observer);\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n\n  // Go to empty tab. Bookmark bar should hide.\n  browser()->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  // Go to ntp tab. Bookmark bar should not show.\n  browser()->tab_strip_model()->ActivateTabAt(\n      1, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  // Repeat with the bookmark bar always visible.\n  browser()->profile()->GetPrefs()->SetBoolean(\n      bookmarks::prefs::kShowBookmarkBar, true);\n  browser()->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_TRUE(bookmark_bar->GetVisible());\n  EXPECT_EQ(1, observer.change_count());\n  observer.clear_change_count();\n\n  browser()->tab_strip_model()->ActivateTabAt(\n      1, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_TRUE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  browser_view()->bookmark_bar()->RemoveObserver(&observer);\n}\n\n// Launch the app, navigate to a page with a title, check that the tab title\n// is set before load finishes and the throbber state updates when the title\n// changes. Regression test for crbug.com/752266\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, TitleAndLoadState) {\n  const std::u16string test_title(u\"Title Of Awesomeness\");\n  auto* contents = browser()->tab_strip_model()->GetActiveWebContents();\n  content::TitleWatcher title_watcher(contents, test_title);\n  content::TestNavigationObserver navigation_watcher(\n      contents, 1, content::MessageLoopRunner::QuitMode::DEFERRED);\n\n  TabStrip* tab_strip = browser_view()->tabstrip();\n  // Navigate without blocking.\n  const GURL test_url = ui_test_utils::GetTestUrl(\n      base::FilePath(base::FilePath::kCurrentDirectory),\n      base::FilePath(FILE_PATH_LITERAL(\"title2.html\")));\n  contents->GetController().LoadURL(test_url, content::Referrer(),\n                                    ui::PAGE_TRANSITION_LINK, std::string());\n  EXPECT_TRUE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kWaiting,\n            tab_strip->tab_at(0)->data().network_state);\n  EXPECT_EQ(test_title, title_watcher.WaitAndGetTitle());\n  EXPECT_TRUE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kLoading,\n            tab_strip->tab_at(0)->data().network_state);\n\n  // Now block for the navigation to complete.\n  navigation_watcher.Wait();\n  EXPECT_FALSE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kNone, tab_strip->tab_at(0)->data().network_state);\n}\n\n// Verifies a tab should show its favicon.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, ShowFaviconInTab) {\n  // Opens \"chrome://version/\" page, which uses default favicon.\n  GURL version_url(chrome::kChromeUIVersionURL);\n  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), version_url));\n  auto* contents = browser()->tab_strip_model()->GetActiveWebContents();\n  auto* helper = TabUIHelper::FromWebContents(contents);\n  ASSERT_TRUE(helper);\n\n  auto favicon = helper->GetFavicon();\n  ASSERT_FALSE(favicon.IsEmpty());\n}\n\n// On Mac, voiceover treats tab modal dialogs as native windows, so setting an\n// accessible title for tab-modal dialogs is not necessary.\n#if !BUILDFLAG(IS_MAC)\n\n// Open a tab-modal dialog and check that the accessible window title is the\n// title of the dialog.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, GetAccessibleTabModalDialogTitle) {\n  std::u16string window_title =\n      u\"about:blank - \" + l10n_util::GetStringUTF16(IDS_PRODUCT_NAME);\n  EXPECT_TRUE(base::StartsWith(browser_view()->GetAccessibleWindowTitle(),\n                               window_title, base::CompareCase::SENSITIVE));\n\n  content::WebContents* contents = browser_view()->GetActiveWebContents();\n  auto delegate = std::make_unique<TestTabModalConfirmDialogDelegate>(contents);\n  TestTabModalConfirmDialogDelegate* delegate_observer = delegate.get();\n  TabModalConfirmDialog::Create(std::move(delegate), contents);\n  EXPECT_EQ(browser_view()->GetAccessibleWindowTitle(),\n            delegate_observer->GetTitle());\n\n  delegate_observer->Close();\n\n  EXPECT_TRUE(base::StartsWith(browser_view()->GetAccessibleWindowTitle(),\n                               window_title, base::CompareCase::SENSITIVE));\n}\n\n// Open a tab-modal dialog and check that the accessibility tree only contains\n// the dialog.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, GetAccessibleTabModalDialogTree) {\n  content::testing::ScopedContentAXModeSetter ax_mode_setter(\n      ui::kAXModeComplete);\n  ui::AXPlatformNode* ax_node = ui::AXPlatformNode::FromNativeViewAccessible(\n      browser_view()->GetWidget()->GetRootView()->GetNativeViewAccessible());\n// We expect this conversion to be safe on Windows, but can't guarantee that it\n// is safe on other platforms.\n#if BUILDFLAG(IS_WIN)\n  ASSERT_TRUE(ax_node);\n#else\n  if (!ax_node)\n    return;\n#endif\n\n  // There is no dialog, but the browser UI should be visible. So we expect the\n  // browser's reload button and no \"OK\" button from a dialog.\n  EXPECT_NE(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"Reload\"),\n            nullptr);\n  EXPECT_EQ(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"OK\"),\n            nullptr);\n\n  content::WebContents* contents = browser_view()->GetActiveWebContents();\n  auto delegate = std::make_unique<TestTabModalConfirmDialogDelegate>(contents);\n  TabModalConfirmDialog::Create(std::move(delegate), contents);\n\n  // The tab modal dialog should be in the accessibility tree; everything else\n  // should be hidden. So we expect an \"OK\" button and no reload button.\n  EXPECT_EQ(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"Reload\"),\n            nullptr);\n  EXPECT_NE(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"OK\"),\n            nullptr);\n}\n\n#endif  // !BUILDFLAG(IS_MAC)\n"
  },
  "written_data": {
    "chrome/browser/ui/views/frame/browser_view_browsertest.cc": "// Copyright 2013 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"chrome/browser/ui/views/frame/browser_view.h\"\n\n#include \"base/memory/raw_ptr.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"build/build_config.h\"\n#include \"build/chromeos_buildflags.h\"\n#include \"chrome/browser/devtools/devtools_window_testing.h\"\n#include \"chrome/browser/ui/browser.h\"\n#include \"chrome/browser/ui/browser_tabstrip.h\"\n#include \"chrome/browser/ui/tab_modal_confirm_dialog.h\"\n#include \"chrome/browser/ui/tab_ui_helper.h\"\n#include \"chrome/browser/ui/tabs/tab_strip_model.h\"\n#include \"chrome/browser/ui/views/bookmarks/bookmark_bar_view.h\"\n#include \"chrome/browser/ui/views/bookmarks/bookmark_bar_view_observer.h\"\n#include \"chrome/browser/ui/views/tabs/tab_strip.h\"\n#include \"chrome/common/pref_names.h\"\n#include \"chrome/common/url_constants.h\"\n#include \"chrome/grit/chromium_strings.h\"\n#include \"chrome/test/base/in_process_browser_test.h\"\n#include \"chrome/test/base/ui_test_utils.h\"\n#include \"components/bookmarks/common/bookmark_pref_names.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"content/public/browser/browser_accessibility_state.h\"\n#include \"content/public/browser/invalidate_type.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"content/public/test/browser_test.h\"\n#include \"content/public/test/browser_test_utils.h\"\n#include \"content/public/test/test_navigation_observer.h\"\n#include \"media/base/media_switches.h\"\n#include \"ui/accessibility/platform/ax_platform_node.h\"\n#include \"ui/accessibility/platform/ax_platform_node_test_helper.h\"\n#include \"ui/base/l10n/l10n_util.h\"\n\n#if defined(USE_AURA)\n#include \"ui/aura/client/focus_client.h\"\n#include \"ui/views/widget/native_widget_aura.h\"\n#endif  // USE_AURA\n\nclass BrowserViewTest : public InProcessBrowserTest {\n public:\n  BrowserViewTest() : devtools_(nullptr) {}\n\n  BrowserViewTest(const BrowserViewTest&) = delete;\n  BrowserViewTest& operator=(const BrowserViewTest&) = delete;\n\n protected:\n  BrowserView* browser_view() {\n    return BrowserView::GetBrowserViewForBrowser(browser());\n  }\n\n  views::WebView* devtools_web_view() {\n    return browser_view()->GetDevToolsWebViewForTest();\n  }\n\n  views::WebView* contents_web_view() {\n    return browser_view()->contents_web_view();\n  }\n\n  void OpenDevToolsWindow(bool docked) {\n    devtools_ =\n        DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), docked);\n  }\n\n  void CloseDevToolsWindow() {\n    DevToolsWindowTesting::CloseDevToolsWindowSync(devtools_);\n  }\n\n  void SetDevToolsBounds(const gfx::Rect& bounds) {\n    DevToolsWindowTesting::Get(devtools_)->SetInspectedPageBounds(bounds);\n  }\n\n  raw_ptr<DevToolsWindow> devtools_;\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\nnamespace {\n\n// Used to simulate scenario in a crash. When WebContentsDestroyed() is invoked\n// updates the navigation state of another tab.\nclass TestWebContentsObserver : public content::WebContentsObserver {\n public:\n  TestWebContentsObserver(content::WebContents* source,\n                          content::WebContents* other)\n      : content::WebContentsObserver(source),\n        other_(other) {}\n\n  TestWebContentsObserver(const TestWebContentsObserver&) = delete;\n  TestWebContentsObserver& operator=(const TestWebContentsObserver&) = delete;\n\n  ~TestWebContentsObserver() override {}\n\n  void WebContentsDestroyed() override {\n    other_->NotifyNavigationStateChanged(static_cast<content::InvalidateTypes>(\n        content::INVALIDATE_TYPE_URL | content::INVALIDATE_TYPE_LOAD));\n  }\n\n private:\n  raw_ptr<content::WebContents> other_;\n};\n\nclass TestTabModalConfirmDialogDelegate : public TabModalConfirmDialogDelegate {\n public:\n  explicit TestTabModalConfirmDialogDelegate(content::WebContents* contents)\n      : TabModalConfirmDialogDelegate(contents) {}\n\n  TestTabModalConfirmDialogDelegate(const TestTabModalConfirmDialogDelegate&) =\n      delete;\n  TestTabModalConfirmDialogDelegate& operator=(\n      const TestTabModalConfirmDialogDelegate&) = delete;\n\n  std::u16string GetTitle() override { return std::u16string(u\"Dialog Title\"); }\n  std::u16string GetDialogMessage() override { return std::u16string(); }\n};\n}  // namespace\n\n// Verifies don't crash when CloseNow() is invoked with two tabs in a browser.\n// Additionally when one of the tabs is destroyed NotifyNavigationStateChanged()\n// is invoked on the other.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, CloseWithTabs) {\n  Browser* browser2 =\n      Browser::Create(Browser::CreateParams(browser()->profile(), true));\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  TestWebContentsObserver observer(\n      browser2->tab_strip_model()->GetWebContentsAt(0),\n      browser2->tab_strip_model()->GetWebContentsAt(1));\n  BrowserView::GetBrowserViewForBrowser(browser2)->GetWidget()->CloseNow();\n}\n\n// Same as CloseWithTabs, but activates the first tab, which is the first tab\n// BrowserView will destroy.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, CloseWithTabsStartWithActive) {\n  Browser* browser2 =\n      Browser::Create(Browser::CreateParams(browser()->profile(), true));\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  chrome::AddTabAt(browser2, GURL(), -1, true);\n  browser2->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  TestWebContentsObserver observer(\n      browser2->tab_strip_model()->GetWebContentsAt(0),\n      browser2->tab_strip_model()->GetWebContentsAt(1));\n  BrowserView::GetBrowserViewForBrowser(browser2)->GetWidget()->CloseNow();\n}\n\n// Verifies that page and devtools WebViews are being correctly layed out\n// when DevTools is opened/closed/updated/undocked.\n// TODO(crbug.com/1316663): Re-enable; currently failing on multiple platforms.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, DISABLED_DevToolsUpdatesBrowserWindow) {\n  gfx::Rect full_bounds =\n      browser_view()->GetContentsContainerForTest()->GetLocalBounds();\n  gfx::Rect small_bounds(10, 20, 30, 40);\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  // Docked.\n  OpenDevToolsWindow(true);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n\n  SetDevToolsBounds(small_bounds);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  CloseDevToolsWindow();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  // Undocked.\n  OpenDevToolsWindow(false);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n\n  SetDevToolsBounds(small_bounds);\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_TRUE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(small_bounds, contents_web_view()->bounds());\n\n  CloseDevToolsWindow();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n\n  browser_view()->UpdateDevTools();\n  EXPECT_FALSE(devtools_web_view()->web_contents());\n  EXPECT_EQ(full_bounds, devtools_web_view()->bounds());\n  EXPECT_EQ(full_bounds, contents_web_view()->bounds());\n}\n\nclass BookmarkBarViewObserverImpl : public BookmarkBarViewObserver {\n public:\n  BookmarkBarViewObserverImpl() : change_count_(0) {\n  }\n\n  BookmarkBarViewObserverImpl(const BookmarkBarViewObserverImpl&) = delete;\n  BookmarkBarViewObserverImpl& operator=(const BookmarkBarViewObserverImpl&) =\n      delete;\n\n  int change_count() const { return change_count_; }\n  void clear_change_count() { change_count_ = 0; }\n\n  // BookmarkBarViewObserver:\n  void OnBookmarkBarVisibilityChanged() override { change_count_++; }\n\n private:\n  int change_count_ = 0;\n};\n\n// Verifies we don't unnecessarily change the visibility of the BookmarkBarView.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, AvoidUnnecessaryVisibilityChanges) {\n  // Create two tabs, the first empty and the second the ntp. Make it so the\n  // BookmarkBarView isn't shown.\n  browser()->profile()->GetPrefs()->SetBoolean(\n      bookmarks::prefs::kShowBookmarkBar, false);\n  GURL new_tab_url(chrome::kChromeUINewTabURL);\n  chrome::AddTabAt(browser(), GURL(), -1, true);\n  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), new_tab_url));\n\n  ASSERT_TRUE(browser_view()->bookmark_bar());\n  BookmarkBarViewObserverImpl observer;\n  BookmarkBarView* bookmark_bar = browser_view()->bookmark_bar();\n  bookmark_bar->AddObserver(&observer);\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n\n  // Go to empty tab. Bookmark bar should hide.\n  browser()->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  // Go to ntp tab. Bookmark bar should not show.\n  browser()->tab_strip_model()->ActivateTabAt(\n      1, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_FALSE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  // Repeat with the bookmark bar always visible.\n  browser()->profile()->GetPrefs()->SetBoolean(\n      bookmarks::prefs::kShowBookmarkBar, true);\n  browser()->tab_strip_model()->ActivateTabAt(\n      0, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_TRUE(bookmark_bar->GetVisible());\n  EXPECT_EQ(1, observer.change_count());\n  observer.clear_change_count();\n\n  browser()->tab_strip_model()->ActivateTabAt(\n      1, TabStripUserGestureDetails(\n             TabStripUserGestureDetails::GestureType::kOther));\n  EXPECT_TRUE(bookmark_bar->GetVisible());\n  EXPECT_EQ(0, observer.change_count());\n  observer.clear_change_count();\n\n  browser_view()->bookmark_bar()->RemoveObserver(&observer);\n}\n\n// Launch the app, navigate to a page with a title, check that the tab title\n// is set before load finishes and the throbber state updates when the title\n// changes. Regression test for crbug.com/752266\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, TitleAndLoadState) {\n  const std::u16string test_title(u\"Title Of Awesomeness\");\n  auto* contents = browser()->tab_strip_model()->GetActiveWebContents();\n  content::TitleWatcher title_watcher(contents, test_title);\n  content::TestNavigationObserver navigation_watcher(\n      contents, 1, content::MessageLoopRunner::QuitMode::DEFERRED);\n\n  TabStrip* tab_strip = browser_view()->tabstrip();\n  // Navigate without blocking.\n  const GURL test_url = ui_test_utils::GetTestUrl(\n      base::FilePath(base::FilePath::kCurrentDirectory),\n      base::FilePath(FILE_PATH_LITERAL(\"title2.html\")));\n  contents->GetController().LoadURL(test_url, content::Referrer(),\n                                    ui::PAGE_TRANSITION_LINK, std::string());\n  EXPECT_TRUE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kWaiting,\n            tab_strip->tab_at(0)->data().network_state);\n  EXPECT_EQ(test_title, title_watcher.WaitAndGetTitle());\n  EXPECT_TRUE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kLoading,\n            tab_strip->tab_at(0)->data().network_state);\n\n  // Now block for the navigation to complete.\n  navigation_watcher.Wait();\n  EXPECT_FALSE(browser()->tab_strip_model()->TabsAreLoading());\n  EXPECT_EQ(TabNetworkState::kNone, tab_strip->tab_at(0)->data().network_state);\n}\n\n// Verifies a tab should show its favicon.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, ShowFaviconInTab) {\n  // Opens \"chrome://version/\" page, which uses default favicon.\n  GURL version_url(chrome::kChromeUIVersionURL);\n  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), version_url));\n  auto* contents = browser()->tab_strip_model()->GetActiveWebContents();\n  auto* helper = TabUIHelper::FromWebContents(contents);\n  ASSERT_TRUE(helper);\n\n  auto favicon = helper->GetFavicon();\n  ASSERT_FALSE(favicon.IsEmpty());\n}\n\n// On Mac, voiceover treats tab modal dialogs as native windows, so setting an\n// accessible title for tab-modal dialogs is not necessary.\n#if !BUILDFLAG(IS_MAC)\n\n// Open a tab-modal dialog and check that the accessible window title is the\n// title of the dialog.\nIN_PROC_BROWSER_TEST_F(BrowserViewTest, GetAccessibleTabModalDialogTitle) {\n  std::u16string window_title =\n      u\"about:blank - \" + l10n_util::GetStringUTF16(IDS_PRODUCT_NAME);\n  EXPECT_TRUE(base::StartsWith(browser_view()->GetAccessibleWindowTitle(),\n                               window_title, base::CompareCase::SENSITIVE));\n\n  content::WebContents* contents = browser_view()->GetActiveWebContents();\n  auto delegate = std::make_unique<TestTabModalConfirmDialogDelegate>(contents);\n  TestTabModalConfirmDialogDelegate* delegate_observer = delegate.get();\n  TabModalConfirmDialog::Create(std::move(delegate), contents);\n  EXPECT_EQ(browser_view()->GetAccessibleWindowTitle(),\n            delegate_observer->GetTitle());\n\n  delegate_observer->Close();\n\n  EXPECT_TRUE(base::StartsWith(browser_view()->GetAccessibleWindowTitle(),\n                               window_title, base::CompareCase::SENSITIVE));\n}\n\n// Open a tab-modal dialog and check that the accessibility tree only contains\n// the dialog.\n// TODO(crbug.com/1234567): Re-enable this test\nIN_PROC_BROWSER_TEST_F(BrowserViewTest,\n                       DISABLED_GetAccessibleTabModalDialogTree) {\n  content::testing::ScopedContentAXModeSetter ax_mode_setter(\n      ui::kAXModeComplete);\n  ui::AXPlatformNode* ax_node = ui::AXPlatformNode::FromNativeViewAccessible(\n      browser_view()->GetWidget()->GetRootView()->GetNativeViewAccessible());\n// We expect this conversion to be safe on Windows, but can't guarantee that it\n// is safe on other platforms.\n#if BUILDFLAG(IS_WIN)\n  ASSERT_TRUE(ax_node);\n#else\n  if (!ax_node)\n    return;\n#endif\n\n  // There is no dialog, but the browser UI should be visible. So we expect the\n  // browser's reload button and no \"OK\" button from a dialog.\n  EXPECT_NE(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"Reload\"),\n            nullptr);\n  EXPECT_EQ(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"OK\"),\n            nullptr);\n\n  content::WebContents* contents = browser_view()->GetActiveWebContents();\n  auto delegate = std::make_unique<TestTabModalConfirmDialogDelegate>(contents);\n  TabModalConfirmDialog::Create(std::move(delegate), contents);\n\n  // The tab modal dialog should be in the accessibility tree; everything else\n  // should be hidden. So we expect an \"OK\" button and no reload button.\n  EXPECT_EQ(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"Reload\"),\n            nullptr);\n  EXPECT_NE(ui::AXPlatformNodeTestHelper::FindChildByName(ax_node, \"OK\"),\n            nullptr);\n}\n\n#endif  // !BUILDFLAG(IS_MAC)\n"
  }
}