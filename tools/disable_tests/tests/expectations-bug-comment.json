{
  "args": [
    "./disable",
    "-b",
    "9191919",
    "8802549688048524353",
    ".*WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset.*"
  ],
  "requests": "{\"QueryTestResults/{\\\"invocations\\\": [\\\"invocations/build-8802549688048524353\\\"], \\\"readMask\\\": {\\\"paths\\\": [\\\"test_id\\\", \\\"test_metadata\\\"]}, \\\"pageSize\\\": 1000, \\\"predicate\\\": {\\\"testIdRegexp\\\": \\\".*WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset.*\\\"}}\": \"{\\\"testResults\\\":[{\\\"name\\\":\\\"invocations/task-chromium-swarm.appspot.com-5d70fea42230d311/tests/ninja:%2F%2Fash:ash_unittests%2FWallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset/results/bb5ad544-02155\\\",\\\"testId\\\":\\\"ninja://ash:ash_unittests/WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset\\\",\\\"testMetadata\\\":{\\\"name\\\":\\\"WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset\\\",\\\"location\\\":{\\\"repo\\\":\\\"https://chromium.googlesource.com/chromium/src\\\",\\\"fileName\\\":\\\"//ash/wallpaper/wallpaper_controller_unittest.cc\\\",\\\"line\\\":4012}}},{\\\"name\\\":\\\"invocations/task-chromium-swarm.appspot.com-5d70fea42230d311/tests/ninja:%2F%2Fash:ash_unittests%2FWallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset/results/bb5ad544-02156\\\",\\\"testId\\\":\\\"ninja://ash:ash_unittests/WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset\\\",\\\"testMetadata\\\":{\\\"name\\\":\\\"WallpaperControllerTest.UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset\\\",\\\"location\\\":{\\\"repo\\\":\\\"https://chromium.googlesource.com/chromium/src\\\",\\\"fileName\\\":\\\"//ash/wallpaper/wallpaper_controller_unittest.cc\\\",\\\"line\\\":4012}}}]}\\n\"}",
  "read_data": {
    "ash/wallpaper/wallpaper_controller_unittest.cc": "// Copyright 2012 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ash/wallpaper/wallpaper_controller_impl.h\"\n\n#include <cmath>\n#include <cstdlib>\n#include <memory>\n#include <vector>\n\n#include \"ash/constants/ash_features.h\"\n#include \"ash/constants/ash_pref_names.h\"\n#include \"ash/constants/ash_switches.h\"\n#include \"ash/public/cpp/shell_window_ids.h\"\n#include \"ash/public/cpp/test/shell_test_api.h\"\n#include \"ash/public/cpp/test/test_image_downloader.h\"\n#include \"ash/public/cpp/wallpaper/online_wallpaper_params.h\"\n#include \"ash/public/cpp/wallpaper/online_wallpaper_variant.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_controller_client.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_controller_observer.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_types.h\"\n#include \"ash/root_window_controller.h\"\n#include \"ash/session/session_controller_impl.h\"\n#include \"ash/session/test_session_controller_client.h\"\n#include \"ash/shell.h\"\n#include \"ash/style/dark_light_mode_controller_impl.h\"\n#include \"ash/test/ash_test_base.h\"\n#include \"ash/wallpaper/test_wallpaper_controller_client.h\"\n#include \"ash/wallpaper/wallpaper_pref_manager.h\"\n#include \"ash/wallpaper/wallpaper_utils/wallpaper_resizer.h\"\n#include \"ash/wallpaper/wallpaper_view.h\"\n#include \"ash/wallpaper/wallpaper_widget_controller.h\"\n#include \"ash/webui/personalization_app/proto/backdrop_wallpaper.pb.h\"\n#include \"ash/wm/overview/overview_controller.h\"\n#include \"ash/wm/window_cycle/window_cycle_controller.h\"\n#include \"ash/wm/window_state.h\"\n#include \"base/callback_helpers.h\"\n#include \"base/command_line.h\"\n#include \"base/files/file_util.h\"\n#include \"base/files/scoped_temp_dir.h\"\n#include \"base/metrics/metrics_hashes.h\"\n#include \"base/run_loop.h\"\n#include \"base/strings/stringprintf.h\"\n#include \"base/task/current_thread.h\"\n#include \"base/task/task_observer.h\"\n#include \"base/task/thread_pool/thread_pool_instance.h\"\n#include \"base/test/bind.h\"\n#include \"base/test/metrics/histogram_tester.h\"\n#include \"base/test/scoped_feature_list.h\"\n#include \"base/test/task_environment.h\"\n#include \"base/test/test_future.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/time/time_override.h\"\n#include \"chromeos/constants/chromeos_features.h\"\n#include \"components/prefs/scoped_user_pref_update.h\"\n#include \"components/user_manager/user_names.h\"\n#include \"components/user_manager/user_type.h\"\n#include \"services/data_decoder/public/cpp/test_support/in_process_data_decoder.h\"\n#include \"testing/gmock/include/gmock/gmock-matchers.h\"\n#include \"third_party/skia/include/core/SkBitmap.h\"\n#include \"third_party/skia/include/core/SkColor.h\"\n#include \"ui/aura/window.h\"\n#include \"ui/compositor/layer.h\"\n#include \"ui/compositor/layer_tree_owner.h\"\n#include \"ui/compositor/scoped_animation_duration_scale_mode.h\"\n#include \"ui/compositor/test/layer_animator_test_controller.h\"\n#include \"ui/display/display.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/gfx/canvas.h\"\n#include \"ui/gfx/codec/jpeg_codec.h\"\n#include \"ui/gfx/color_analysis.h\"\n#include \"ui/views/view_tracker.h\"\n#include \"ui/views/widget/widget.h\"\n\nusing session_manager::SessionState;\n\nnamespace ash {\nnamespace {\n\n// Containers IDs used for tests.\nconstexpr int kWallpaperId = kShellWindowId_WallpaperContainer;\nconstexpr int kLockScreenWallpaperId =\n    kShellWindowId_LockScreenWallpaperContainer;\nconstexpr int kAlwaysOnTopWallpaperId =\n    kShellWindowId_AlwaysOnTopWallpaperContainer;\n\nconstexpr char kDefaultSmallWallpaperName[] = \"small.jpg\";\nconstexpr char kDefaultLargeWallpaperName[] = \"large.jpg\";\nconstexpr char kGuestSmallWallpaperName[] = \"guest_small.jpg\";\nconstexpr char kGuestLargeWallpaperName[] = \"guest_large.jpg\";\nconstexpr char kChildSmallWallpaperName[] = \"child_small.jpg\";\nconstexpr char kChildLargeWallpaperName[] = \"child_large.jpg\";\n\nconstexpr char kCustomizationSmallWallpaperName[] = \"small_customization.jpeg\";\nconstexpr char kCustomizationLargeWallpaperName[] = \"large_customization.jpeg\";\n\n// Colors used to distinguish between wallpapers with large and small\n// resolution.\nconstexpr SkColor kLargeCustomWallpaperColor = SK_ColorDKGRAY;\nconstexpr SkColor kSmallCustomWallpaperColor = SK_ColorLTGRAY;\n\n// A color that can be passed to |CreateImage|. Specifically chosen to not\n// conflict with any of the custom wallpaper colors.\nconstexpr SkColor kWallpaperColor = SK_ColorMAGENTA;\n\nstd::string GetDummyFileId(const AccountId& account_id) {\n  return account_id.GetUserEmail() + \"-hash\";\n}\n\nstd::string GetDummyFileName(const AccountId& account_id) {\n  return account_id.GetUserEmail() + \"-file\";\n}\n\nconstexpr char kUser1[] = \"user1@test.com\";\nconst AccountId account_id_1 = AccountId::FromUserEmailGaiaId(kUser1, kUser1);\nconst std::string wallpaper_files_id_1 = GetDummyFileId(account_id_1);\nconst std::string file_name_1 = GetDummyFileName(account_id_1);\n\nconstexpr char kUser2[] = \"user2@test.com\";\nconst AccountId account_id_2 = AccountId::FromUserEmailGaiaId(kUser2, kUser2);\nconst std::string wallpaper_files_id_2 = GetDummyFileId(account_id_2);\nconst std::string file_name_2 = GetDummyFileName(account_id_2);\n\nconstexpr char kChildEmail[] = \"child@test.com\";\n\nconst std::string kDummyUrl = \"https://best_wallpaper/1\";\nconst std::string kDummyUrl2 = \"https://best_wallpaper/2\";\n\nconst uint64_t kAssetId = 1;\nconst uint64_t kAssetId2 = 2;\nconst uint64_t kUnitId = 1;\nconst uint64_t kUnitId2 = 2;\n\nconst std::string kFakeGooglePhotosAlbumId = \"fake_album\";\nconst std::string kFakeGooglePhotosPhotoId = \"fake_photo\";\n\n// Creates an image of size |size|.\ngfx::ImageSkia CreateImage(int width, int height, SkColor color) {\n  SkBitmap bitmap;\n  bitmap.allocN32Pixels(width, height);\n  bitmap.eraseColor(color);\n  gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(bitmap);\n  return image;\n}\n\n// Returns number of child windows in a shell window container.\nint ChildCountForContainer(int container_id) {\n  aura::Window* root = Shell::Get()->GetPrimaryRootWindow();\n  aura::Window* container = root->GetChildById(container_id);\n  return static_cast<int>(container->children().size());\n}\n\n// Steps a layer animation until it is completed. Animations must be enabled.\nvoid RunAnimationForLayer(ui::Layer* layer) {\n  // Animations must be enabled for stepping to work.\n  ASSERT_NE(ui::ScopedAnimationDurationScaleMode::duration_multiplier(),\n            ui::ScopedAnimationDurationScaleMode::ZERO_DURATION);\n\n  ui::LayerAnimatorTestController controller(layer->GetAnimator());\n  // Multiple steps are required to complete complex animations.\n  // TODO(vollick): This should not be necessary. crbug.com/154017\n  while (controller.animator()->is_animating()) {\n    controller.StartThreadedAnimationsIfNeeded();\n    base::TimeTicks step_time = controller.animator()->last_step_time();\n    layer->GetAnimator()->Step(step_time + base::Milliseconds(1000));\n  }\n}\n\n// Writes a JPEG image of the specified size and color to |path|. Returns true\n// on success.\nbool WriteJPEGFile(const base::FilePath& path,\n                   int width,\n                   int height,\n                   SkColor color) {\n  base::ScopedAllowBlockingForTesting allow_blocking;\n  SkBitmap bitmap;\n  bitmap.allocN32Pixels(width, height);\n  bitmap.eraseColor(color);\n  std::vector<unsigned char> output;\n  if (!gfx::JPEGCodec::Encode(bitmap, 80 /*quality*/, &output)) {\n    LOG(ERROR) << \"Unable to encode \" << width << \"x\" << height << \" bitmap\";\n    return false;\n  }\n\n  size_t bytes_written = base::WriteFile(\n      path, reinterpret_cast<const char*>(&output[0]), output.size());\n  if (bytes_written != output.size()) {\n    LOG(ERROR) << \"Wrote \" << bytes_written << \" byte(s) instead of \"\n               << output.size() << \" to \" << path.value();\n    return false;\n  }\n  return true;\n}\n\n// Returns custom wallpaper path. Creates the directory if it doesn't exist.\nbase::FilePath GetCustomWallpaperPath(const char* sub_dir,\n                                      const std::string& wallpaper_files_id,\n                                      const std::string& file_name) {\n  base::ScopedAllowBlockingForTesting allow_blocking;\n  base::FilePath wallpaper_path =\n      WallpaperControllerImpl::GetCustomWallpaperPath(\n          sub_dir, wallpaper_files_id, file_name);\n  if (!base::DirectoryExists(wallpaper_path.DirName()))\n    base::CreateDirectory(wallpaper_path.DirName());\n\n  return wallpaper_path;\n}\n\nvoid WaitUntilCustomWallpapersDeleted(const AccountId& account_id) {\n  const std::string wallpaper_file_id = GetDummyFileId(account_id);\n\n  base::FilePath small_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kSmallWallpaperSubDir)\n          .Append(wallpaper_file_id);\n  base::FilePath large_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kLargeWallpaperSubDir)\n          .Append(wallpaper_file_id);\n  base::FilePath original_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kOriginalWallpaperSubDir)\n          .Append(wallpaper_file_id);\n\n  while (base::PathExists(small_wallpaper_dir) ||\n         base::PathExists(large_wallpaper_dir) ||\n         base::PathExists(original_wallpaper_dir)) {\n  }\n}\n\n// Monitors if any task is processed by the message loop.\nclass TaskObserver : public base::TaskObserver {\n public:\n  TaskObserver() : processed_(false) {}\n\n  TaskObserver(const TaskObserver&) = delete;\n  TaskObserver& operator=(const TaskObserver&) = delete;\n\n  ~TaskObserver() override = default;\n\n  // TaskObserver:\n  void WillProcessTask(const base::PendingTask& /* pending_task */,\n                       bool /* was_blocked_or_low_priority */) override {}\n  void DidProcessTask(const base::PendingTask& pending_task) override {\n    processed_ = true;\n  }\n\n  // Returns true if any task was processed.\n  bool processed() const { return processed_; }\n\n private:\n  bool processed_;\n};\n\n// See content::RunAllTasksUntilIdle().\nvoid RunAllTasksUntilIdle() {\n  while (true) {\n    TaskObserver task_observer;\n    base::CurrentThread::Get()->AddTaskObserver(&task_observer);\n    // May spin message loop.\n    base::ThreadPoolInstance::Get()->FlushForTesting();\n\n    base::RunLoop().RunUntilIdle();\n    base::CurrentThread::Get()->RemoveTaskObserver(&task_observer);\n\n    if (!task_observer.processed())\n      break;\n  }\n}\n\nPrefService* GetProfilePrefService(const AccountId& account_id) {\n  return Shell::Get()->session_controller()->GetUserPrefServiceForUser(\n      account_id);\n}\n\nWallpaperInfo InfoWithType(WallpaperType type) {\n  WallpaperInfo info(std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, type,\n                     base::Time::Now());\n  if (type == WallpaperType::kDaily || type == WallpaperType::kOnline) {\n    // Daily and Online types require asset id and collection id.\n    info.asset_id = 1234;\n    info.collection_id = \"placeholder collection\";\n    info.location = \"https://example.com/example.jpeg\";\n  }\n  if (type == WallpaperType::kOnceGooglePhotos)\n    info.dedup_key = \"dedup_key\";\n  return info;\n}\n\nbase::Time DayBeforeYesterdayish() {\n  base::TimeDelta today_delta =\n      base::Time::Now().LocalMidnight().ToDeltaSinceWindowsEpoch();\n  base::TimeDelta yesterday_delta = today_delta - base::Days(2);\n  return base::Time::FromDeltaSinceWindowsEpoch(yesterday_delta);\n}\n\n// A test implementation of the WallpaperControllerObserver interface.\nclass TestWallpaperControllerObserver : public WallpaperControllerObserver {\n public:\n  explicit TestWallpaperControllerObserver(WallpaperController* controller)\n      : controller_(controller) {\n    controller_->AddObserver(this);\n  }\n\n  TestWallpaperControllerObserver(const TestWallpaperControllerObserver&) =\n      delete;\n  TestWallpaperControllerObserver& operator=(\n      const TestWallpaperControllerObserver&) = delete;\n\n  ~TestWallpaperControllerObserver() override {\n    controller_->RemoveObserver(this);\n  }\n\n  // WallpaperControllerObserver\n  void OnWallpaperChanged() override { ++wallpaper_changed_count_; }\n  void OnWallpaperColorsChanged() override { ++colors_changed_count_; }\n  void OnWallpaperBlurChanged() override { ++blur_changed_count_; }\n  void OnFirstWallpaperShown() override { ++first_shown_count_; }\n  void OnWallpaperPreviewStarted() override {\n    DCHECK(!is_in_wallpaper_preview_);\n    is_in_wallpaper_preview_ = true;\n  }\n  void OnWallpaperPreviewEnded() override {\n    DCHECK(is_in_wallpaper_preview_);\n    is_in_wallpaper_preview_ = false;\n  }\n\n  int colors_changed_count() const { return colors_changed_count_; }\n  int blur_changed_count() const { return blur_changed_count_; }\n  int first_shown_count() const { return first_shown_count_; }\n  int wallpaper_changed_count() const { return wallpaper_changed_count_; }\n  bool is_in_wallpaper_preview() const { return is_in_wallpaper_preview_; }\n\n private:\n  WallpaperController* controller_;\n  int colors_changed_count_ = 0;\n  int blur_changed_count_ = 0;\n  int first_shown_count_ = 0;\n  int wallpaper_changed_count_ = 0;\n  bool is_in_wallpaper_preview_ = false;\n};\n\n}  // namespace\n\nclass WallpaperControllerTest : public AshTestBase {\n public:\n  WallpaperControllerTest()\n      : AshTestBase(base::test::TaskEnvironment::TimeSource::MOCK_TIME) {}\n\n  WallpaperControllerTest(const WallpaperControllerTest&) = delete;\n  WallpaperControllerTest& operator=(const WallpaperControllerTest&) = delete;\n\n  void SetUp() override {\n    auto pref_manager = WallpaperPrefManager::Create(local_state());\n    pref_manager_ = pref_manager.get();\n    // Override the pref manager that will be used to construct the\n    // WallpaperController.\n    WallpaperControllerImpl::SetWallpaperPrefManagerForTesting(\n        std::move(pref_manager));\n\n    AshTestBase::SetUp();\n\n    TestSessionControllerClient* const client = GetSessionControllerClient();\n    client->ProvidePrefServiceForUser(account_id_1);\n    client->ProvidePrefServiceForUser(account_id_2);\n    client->ProvidePrefServiceForUser(\n        AccountId::FromUserEmail(user_manager::kGuestUserName));\n    client->ProvidePrefServiceForUser(kChildAccountId);\n\n    // This is almost certainly not what was originally intended for these\n    // tests, but they have never actually exercised properly decoded\n    // wallpapers, as they've never actually been connected to a Data Decoder.\n    // We simulate a \"crashing\" ImageDcoder to get the behavior the tests were\n    // written around, but at some point they should probably be fixed.\n    in_process_data_decoder_.service().SimulateImageDecoderCrashForTesting(\n        true);\n\n    test_image_downloader_ = std::make_unique<TestImageDownloader>();\n\n    controller_ = Shell::Get()->wallpaper_controller();\n    controller_->set_wallpaper_reload_no_delay_for_test();\n\n    ASSERT_TRUE(user_data_dir_.CreateUniqueTempDir());\n    ASSERT_TRUE(online_wallpaper_dir_.CreateUniqueTempDir());\n    ASSERT_TRUE(custom_wallpaper_dir_.CreateUniqueTempDir());\n    base::FilePath policy_wallpaper;\n    controller_->Init(user_data_dir_.GetPath(), online_wallpaper_dir_.GetPath(),\n                      custom_wallpaper_dir_.GetPath(), policy_wallpaper);\n    client_.ResetCounts();\n    controller_->SetClient(&client_);\n    client_.set_fake_files_id_for_account_id(account_id_1,\n                                             wallpaper_files_id_1);\n    client_.set_fake_files_id_for_account_id(account_id_2,\n                                             wallpaper_files_id_2);\n  }\n\n  void TearDown() override {\n    // Although pref services outlive wallpaper controller in the os, in ash\n    // tests, they are destroyed in tear down (See |AshTestHelper|). We don't\n    // want this timer to run a task after tear down, since it relies on a pref\n    // service being around.\n    controller_->GetUpdateWallpaperTimerForTesting().Stop();\n\n    AshTestBase::TearDown();\n  }\n\n  WallpaperView* wallpaper_view() {\n    return Shell::Get()\n        ->GetPrimaryRootWindowController()\n        ->wallpaper_widget_controller()\n        ->wallpaper_view();\n  }\n\n protected:\n  // Helper function that tests the wallpaper is always fitted to the native\n  // display resolution when the layout is WALLPAPER_LAYOUT_CENTER.\n  void WallpaperFitToNativeResolution(WallpaperView* view,\n                                      float device_scale_factor,\n                                      int image_width,\n                                      int image_height,\n                                      SkColor color) {\n    gfx::Size size = view->bounds().size();\n    gfx::Canvas canvas(size, device_scale_factor, true);\n    view->OnPaint(&canvas);\n\n    SkBitmap bitmap = canvas.GetBitmap();\n    int bitmap_width = bitmap.width();\n    int bitmap_height = bitmap.height();\n    for (int i = 0; i < bitmap_width; i++) {\n      for (int j = 0; j < bitmap_height; j++) {\n        if (i >= (bitmap_width - image_width) / 2 &&\n            i < (bitmap_width + image_width) / 2 &&\n            j >= (bitmap_height - image_height) / 2 &&\n            j < (bitmap_height + image_height) / 2) {\n          EXPECT_EQ(color, bitmap.getColor(i, j));\n        } else {\n          EXPECT_EQ(SK_ColorBLACK, bitmap.getColor(i, j));\n        }\n      }\n    }\n  }\n\n  // Runs AnimatingWallpaperWidgetController's animation to completion.\n  void RunDesktopControllerAnimation() {\n    WallpaperWidgetController* controller =\n        Shell::Get()\n            ->GetPrimaryRootWindowController()\n            ->wallpaper_widget_controller();\n    ASSERT_TRUE(controller);\n\n    ui::LayerTreeOwner* owner = controller->old_layer_tree_owner_for_testing();\n    if (!owner)\n      return;\n\n    ASSERT_NO_FATAL_FAILURE(RunAnimationForLayer(owner->root()));\n  }\n\n  // Convenience function to ensure ShouldCalculateColors() returns true.\n  void EnableShelfColoring() {\n    const gfx::ImageSkia kImage = CreateImage(10, 10, kWallpaperColor);\n    controller_->ShowWallpaperImage(\n        kImage, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    SetSessionState(SessionState::ACTIVE);\n\n    EXPECT_TRUE(ShouldCalculateColors());\n  }\n\n  // Convenience function to set the SessionState.\n  void SetSessionState(SessionState session_state) {\n    GetSessionControllerClient()->SetSessionState(session_state);\n  }\n\n  // Helper function to create a |WallpaperInfo| struct with dummy values\n  // given the desired layout.\n  WallpaperInfo CreateWallpaperInfo(WallpaperLayout layout) {\n    return WallpaperInfo(std::string(), layout, WallpaperType::kDefault,\n                         base::Time::Now().LocalMidnight());\n  }\n\n  // Saves wallpaper images in the appropriate location for |account_id| and\n  // returns the relative path of the file.\n  base::FilePath PrecacheWallpapers(const AccountId& account_id) {\n    std::string wallpaper_files_id = GetDummyFileId(account_id);\n\n    std::string file_name = GetDummyFileName(account_id);\n    base::FilePath small_wallpaper_path =\n        GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                               wallpaper_files_id, file_name);\n    base::FilePath large_wallpaper_path =\n        GetCustomWallpaperPath(WallpaperControllerImpl::kLargeWallpaperSubDir,\n                               wallpaper_files_id, file_name);\n\n    // Saves the small/large resolution wallpapers to small/large custom\n    // wallpaper paths.\n    CHECK(WriteJPEGFile(small_wallpaper_path, kSmallWallpaperMaxWidth,\n                        kSmallWallpaperMaxHeight, kSmallCustomWallpaperColor));\n    CHECK(WriteJPEGFile(large_wallpaper_path, kLargeWallpaperMaxWidth,\n                        kLargeWallpaperMaxHeight, kLargeCustomWallpaperColor));\n\n    return base::FilePath(wallpaper_files_id).Append(file_name);\n  }\n\n  // Saves images with different resolution to corresponding paths and saves\n  // wallpaper info to local state, so that subsequent calls of |ShowWallpaper|\n  // can retrieve the images and info.\n  void CreateAndSaveWallpapers(const AccountId& account_id) {\n    base::FilePath relative_path = PrecacheWallpapers(account_id);\n    // Saves wallpaper info to local state for user.\n    WallpaperInfo info = {\n        relative_path.value(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n        WallpaperType::kCustomized, base::Time::Now().LocalMidnight()};\n    ASSERT_TRUE(pref_manager_->SetUserWallpaperInfo(account_id, info));\n  }\n\n  // Simulates setting a custom wallpaper by directly setting the wallpaper\n  // info.\n  void SimulateSettingCustomWallpaper(const AccountId& account_id) {\n    ASSERT_TRUE(pref_manager_->SetUserWallpaperInfo(\n        account_id,\n        WallpaperInfo(\"dummy_file_location\", WALLPAPER_LAYOUT_CENTER,\n                      WallpaperType::kCustomized,\n                      base::Time::Now().LocalMidnight())));\n  }\n\n  // Initializes default wallpaper paths \"*default_*file\" and writes JPEG\n  // wallpaper images to them. Only needs to be called (once) by tests that\n  // want to test loading of default wallpapers.\n  void CreateDefaultWallpapers() {\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    ASSERT_TRUE(default_wallpaper_dir_.CreateUniqueTempDir());\n    const base::FilePath default_wallpaper_path =\n        default_wallpaper_dir_.GetPath();\n\n    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n    const base::FilePath small_file =\n        default_wallpaper_path.Append(kDefaultSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kDefaultWallpaperSmall,\n                                    small_file.value());\n    const base::FilePath large_file =\n        default_wallpaper_path.Append(kDefaultLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kDefaultWallpaperLarge,\n                                    large_file.value());\n\n    const base::FilePath guest_small_file =\n        default_wallpaper_path.Append(kGuestSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kGuestWallpaperSmall,\n                                    guest_small_file.value());\n    const base::FilePath guest_large_file =\n        default_wallpaper_path.Append(kGuestLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kGuestWallpaperLarge,\n                                    guest_large_file.value());\n\n    const base::FilePath child_small_file =\n        default_wallpaper_path.Append(kChildSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kChildWallpaperSmall,\n                                    child_small_file.value());\n    const base::FilePath child_large_file =\n        default_wallpaper_path.Append(kChildLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kChildWallpaperLarge,\n                                    child_large_file.value());\n\n    const int kWallpaperSize = 2;\n    ASSERT_TRUE(WriteJPEGFile(small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n\n    ASSERT_TRUE(WriteJPEGFile(guest_small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(guest_large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n\n    ASSERT_TRUE(WriteJPEGFile(child_small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(child_large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n  }\n\n  // Returns the paths of a small and large jpeg for use with customized default\n  // wallpapers.\n  [[nodiscard]] std::pair<const base::FilePath, const base::FilePath>\n  CreateCustomizationWallpapers() {\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    CHECK(customization_wallpaper_dir_.CreateUniqueTempDir());\n\n    base::FilePath root = customization_wallpaper_dir_.GetPath();\n\n    const base::FilePath small_file =\n        root.Append(kCustomizationSmallWallpaperName);\n    const base::FilePath large_file =\n        root.Append(kCustomizationLargeWallpaperName);\n\n    CHECK(WriteJPEGFile(small_file, 800, 800, SK_ColorGREEN));\n    CHECK(WriteJPEGFile(large_file, 2000, 2000, SK_ColorBLUE));\n\n    return {small_file, large_file};\n  }\n\n  // A helper to test the behavior of setting online wallpaper after the image\n  // is decoded. This is needed because image decoding is not supported in unit\n  // tests.\n  void SetOnlineWallpaperFromImage(\n      const AccountId& account_id,\n      uint64_t asset_id,\n      const gfx::ImageSkia& image,\n      const std::string& url,\n      const std::string& collection_id,\n      WallpaperLayout layout,\n      bool save_file,\n      bool preview_mode,\n      bool from_user,\n      uint64_t unit_id,\n      const std::vector<OnlineWallpaperVariant>& variants,\n      WallpaperController::SetWallpaperCallback callback) {\n    const OnlineWallpaperParams params = {\n        account_id, asset_id,     GURL(url), collection_id,\n        layout,     preview_mode, from_user, /*daily_refresh_enabled=*/false,\n        unit_id,    variants};\n    controller_->OnOnlineWallpaperDecoded(params, save_file,\n                                          std::move(callback), image);\n  }\n\n  // Returns color of the current wallpaper. Note: this function assumes the\n  // wallpaper has a solid color.\n  SkColor GetWallpaperColor() {\n    const gfx::ImageSkiaRep& representation =\n        controller_->GetWallpaper().GetRepresentation(1.0f);\n    return representation.GetBitmap().getColor(0, 0);\n  }\n\n  // Wrapper for private ShouldCalculateColors().\n  bool ShouldCalculateColors() { return controller_->ShouldCalculateColors(); }\n\n  // Wrapper for private IsDevicePolicyWallpaper().\n  bool IsDevicePolicyWallpaper() {\n    return controller_->IsDevicePolicyWallpaper();\n  }\n\n  int GetWallpaperCount() { return controller_->wallpaper_count_for_testing_; }\n\n  const std::vector<base::FilePath>& GetDecodeFilePaths() {\n    return controller_->decode_requests_for_testing_;\n  }\n\n  // Returns the `WallpaperInfo` associated with the current\n  // `WallpaperResizer`. Usually, this is the same as\n  // `GetActiveUserWallpaperInfo()` except when the user is not logged in.\n  const WallpaperInfo GetCurrentWallpaperInfo() {\n    WallpaperResizer* wallpaper = controller_->current_wallpaper_.get();\n    if (!wallpaper)\n      return WallpaperInfo();\n\n    return wallpaper->wallpaper_info();\n  }\n\n  void SetBypassDecode() { controller_->set_bypass_decode_for_testing(); }\n\n  void ClearWallpaperCount() { controller_->wallpaper_count_for_testing_ = 0; }\n\n  void ClearDecodeFilePaths() {\n    controller_->decode_requests_for_testing_.clear();\n  }\n\n  void ClearWallpaper() { controller_->current_wallpaper_.reset(); }\n\n  int GetWallpaperContainerId() {\n    return controller_->GetWallpaperContainerId(controller_->locked_);\n  }\n\n  const base::HistogramTester& histogram_tester() const {\n    return histogram_tester_;\n  }\n\n  void CacheOnlineWallpaper(std::string path) {\n    // Set an Online Wallpaper from Data, so syncing in doesn't need to download\n    // an Online Wallpaper.\n    SetBypassDecode();\n    SimulateUserLogin(account_id_1);\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaperFromData(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(path),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        /*image_data=*/std::string(),\n        WallpaperController::SetWallpaperCallback());\n    RunAllTasksUntilIdle();\n\n    // Change the on-screen wallpaper to a different one. (Otherwise the\n    // subsequent calls will be no-op since we intentionally prevent reloading\n    // the same wallpaper.)\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(\n        account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER_CROPPED,\n        CreateImage(640, 480, kWallpaperColor), false /*preview_mode=*/);\n    RunAllTasksUntilIdle();\n  }\n\n  WallpaperControllerImpl* controller_;\n  WallpaperPrefManager* pref_manager_ = nullptr;  // owned by controller\n\n  base::ScopedTempDir user_data_dir_;\n  base::ScopedTempDir online_wallpaper_dir_;\n  base::ScopedTempDir custom_wallpaper_dir_;\n  base::ScopedTempDir default_wallpaper_dir_;\n  base::ScopedTempDir customization_wallpaper_dir_;\n  base::HistogramTester histogram_tester_;\n\n  TestWallpaperControllerClient client_;\n  std::unique_ptr<TestImageDownloader> test_image_downloader_;\n\n  const AccountId kChildAccountId =\n      AccountId::FromUserEmailGaiaId(kChildEmail, kChildEmail);\n\n private:\n  data_decoder::test::InProcessDataDecoder in_process_data_decoder_;\n};\n\nTEST_F(WallpaperControllerTest, Client) {\n  base::FilePath empty_path;\n  controller_->Init(empty_path, empty_path, empty_path, empty_path);\n\n  EXPECT_EQ(0u, client_.open_count());\n  EXPECT_TRUE(controller_->CanOpenWallpaperPicker());\n  controller_->OpenWallpaperPickerIfAllowed();\n  EXPECT_EQ(1u, client_.open_count());\n}\n\nTEST_F(WallpaperControllerTest, BasicReparenting) {\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Wallpaper view/window exists in the wallpaper container and nothing is in\n  // the lock screen wallpaper container.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n\n  controller->OnSessionStateChanged(session_manager::SessionState::LOCKED);\n\n  // One window is moved from desktop to lock container.\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kLockScreenWallpaperId));\n\n  controller->OnSessionStateChanged(session_manager::SessionState::ACTIVE);\n\n  // One window is moved from lock to desktop container.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n}\n\nTEST_F(WallpaperControllerTest, SwitchWallpapersWhenNewWallpaperAnimationEnds) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Create the wallpaper and its view.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // The new wallpaper is ready to animate.\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n\n  // Force the animation to play to completion.\n  RunDesktopControllerAnimation();\n  EXPECT_FALSE(widget_controller->IsAnimating());\n}\n\n// Test for crbug.com/149043 \"Unlock screen, no launcher appears\". Ensure we\n// move all wallpaper views if there are more than one.\nTEST_F(WallpaperControllerTest, WallpaperMovementDuringUnlock) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Reset wallpaper state, see ControllerOwnership above.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  // User locks the screen, which moves the wallpaper forward.\n  controller->OnSessionStateChanged(session_manager::SessionState::LOCKED);\n\n  // Suspend/resume cycle causes wallpaper to refresh, loading a new wallpaper\n  // that will animate in on top of the old one.\n  controller->CreateEmptyWallpaperForTesting();\n\n  // In this state we have a wallpaper views stored in\n  // LockScreenWallpaperContainer.\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kLockScreenWallpaperId));\n  // There must be three layers, shield, original and old layers.\n  ASSERT_EQ(3u, wallpaper_view()->layer()->parent()->children().size());\n\n  // Before the wallpaper's animation completes, user unlocks the screen, which\n  // moves the wallpaper to the back.\n  controller->OnSessionStateChanged(session_manager::SessionState::ACTIVE);\n\n  // Ensure that widget has moved.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  // There must be two layers, original and old layers while animating.\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n\n  // Finish the new wallpaper animation.\n  RunDesktopControllerAnimation();\n\n  // Now there is one wallpaper and layer.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  ASSERT_EQ(1u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n}\n\n// Test for crbug.com/156542. Animating wallpaper should immediately finish\n// animation and replace current wallpaper before next animation starts.\nTEST_F(WallpaperControllerTest, ChangeWallpaperQuick) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Reset wallpaper state, see ControllerOwnership above.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  // Change to a new wallpaper.\n  controller->CreateEmptyWallpaperForTesting();\n\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n\n  // Change to another wallpaper before animation finished.\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  EXPECT_FALSE(widget_controller->IsAnimating());\n}\n\nTEST_F(WallpaperControllerTest, ResizeCustomWallpaper) {\n  UpdateDisplay(\"320x200\");\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n\n  // Set the image as custom wallpaper, wait for the resize to finish, and check\n  // that the resized image is the expected size.\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  EXPECT_TRUE(image.BackedBySameObjectAs(controller_->GetWallpaper()));\n  RunAllTasksUntilIdle();\n  gfx::ImageSkia resized_image = controller_->GetWallpaper();\n  EXPECT_FALSE(image.BackedBySameObjectAs(resized_image));\n  EXPECT_EQ(gfx::Size(320, 200).ToString(), resized_image.size().ToString());\n\n  // Load the original wallpaper again and check that we're still using the\n  // previously-resized image instead of doing another resize\n  // (http://crbug.com/321402).\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(resized_image.BackedBySameObjectAs(controller_->GetWallpaper()));\n}\n\nTEST_F(WallpaperControllerTest, GetMaxDisplaySize) {\n  // Device scale factor shouldn't affect the native size.\n  UpdateDisplay(\"1000x300*2\");\n  EXPECT_EQ(\"1000x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Rotated display should return the rotated size.\n  UpdateDisplay(\"1000x300*2/r\");\n  EXPECT_EQ(\"300x1000\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // UI Scaling shouldn't affect the native size.\n  UpdateDisplay(\"1000x300*2@1.5\");\n  EXPECT_EQ(\"1000x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // First display has maximum size.\n  UpdateDisplay(\"400x300,200x100\");\n  EXPECT_EQ(\"400x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Second display has maximum size.\n  UpdateDisplay(\"400x300,500x600\");\n  EXPECT_EQ(\"500x600\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Maximum width and height belongs to different displays.\n  UpdateDisplay(\"400x300,100x500\");\n  EXPECT_EQ(\"400x500\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n}\n\n// Test that the wallpaper is always fitted to the native display resolution\n// when the layout is WALLPAPER_LAYOUT_CENTER to prevent blurry images.\nTEST_F(WallpaperControllerTest, DontScaleWallpaperWithCenterLayout) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  const gfx::Size high_resolution(3600, 2400);\n  const gfx::Size low_resolution(360, 240);\n  const float high_dsf = 2.0f;\n  const float low_dsf = 1.0f;\n\n  gfx::ImageSkia image_high_res = CreateImage(\n      high_resolution.width(), high_resolution.height(), kWallpaperColor);\n  gfx::ImageSkia image_low_res = CreateImage(\n      low_resolution.width(), low_resolution.height(), kWallpaperColor);\n\n  UpdateDisplay(\"1200x600*2\");\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600*2 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600*2 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n\n  UpdateDisplay(\"1200x600\");\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n\n  UpdateDisplay(\"1200x600/u@1.5\");  // 1.5 ui scale\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600/u@1.5 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600/u@1.5 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n}\n\nTEST_F(WallpaperControllerTest, ShouldCalculateColorsBasedOnImage) {\n  EnableShelfColoring();\n  EXPECT_TRUE(ShouldCalculateColors());\n\n  controller_->CreateEmptyWallpaperForTesting();\n  EXPECT_FALSE(ShouldCalculateColors());\n}\n\nTEST_F(WallpaperControllerTest, ShouldCalculateColorsBasedOnSessionState) {\n  EnableShelfColoring();\n\n  SetSessionState(SessionState::UNKNOWN);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::OOBE);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_TRUE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  EXPECT_FALSE(ShouldCalculateColors());\n}\n\nTEST_F(WallpaperControllerTest, EnableShelfColoringNotifiesObservers) {\n  TestWallpaperControllerObserver observer(controller_);\n  EXPECT_EQ(0, observer.colors_changed_count());\n\n  // Enable shelf coloring will set a customized wallpaper image and change\n  // session state to ACTIVE, which will trigger wallpaper colors calculation.\n  EnableShelfColoring();\n  base::RunLoop().RunUntilIdle();\n  EXPECT_EQ(1, observer.colors_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, ProminentColor_CachedColorsAvailableAtLogin) {\n  SetBypassDecode();\n  // Cache some wallpapers and store that in the local prefs. Otherwise, we\n  // can't cache colors.\n  base::FilePath relative_path = PrecacheWallpapers(account_id_1);\n  WallpaperInfo info = InfoWithType(WallpaperType::kCustomized);\n  info.location = relative_path.value();\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_1, info));\n\n  // Store colors in local prefs simulating cache behavior.\n  const std::vector<SkColor> prominent_colors = {SK_ColorGREEN, SK_ColorRED,\n                                                 SK_ColorBLUE,  SK_ColorWHITE,\n                                                 SK_ColorWHITE, SK_ColorWHITE};\n  pref_manager_->CacheProminentColors(account_id_1, prominent_colors);\n  const SkColor k_means_color = SK_ColorLTGRAY;\n  pref_manager_->CacheKMeanColor(account_id_1, k_means_color);\n\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  TestWallpaperControllerObserver observer(controller_);\n  ASSERT_EQ(0, observer.colors_changed_count());\n\n  // Show user wallpaper in login screen. We are *not* logged in yet.\n  controller_->ShowUserWallpaper(account_id_1,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n\n  // Showing a user wallpaper should cause the cached colors to be fetched and\n  // reported.\n  EXPECT_EQ(1, observer.colors_changed_count());\n\n  // DARK_VIBRANT happens to be prominent color 0.\n  EXPECT_EQ(SK_ColorGREEN, controller_->GetProminentColor(\n                               {color_utils::LumaRange::DARK,\n                                color_utils::SaturationRange::VIBRANT}));\n  EXPECT_EQ(k_means_color, controller_->GetKMeanColor());\n}\n\nTEST_F(WallpaperControllerTest, ProminentColor_ClearedBetweenUsers) {\n  SetBypassDecode();\n  // Setup prominent colors for account 1.\n  base::FilePath relative_path = PrecacheWallpapers(account_id_1);\n  WallpaperInfo info = InfoWithType(WallpaperType::kCustomized);\n  info.location = relative_path.value();\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_1, info));\n\n  const std::vector<SkColor> prominent_colors = {SK_ColorGREEN, SK_ColorRED,\n                                                 SK_ColorBLUE,  SK_ColorWHITE,\n                                                 SK_ColorWHITE, SK_ColorWHITE};\n  pref_manager_->CacheProminentColors(account_id_1, prominent_colors);\n  const SkColor k_means_color = SK_ColorLTGRAY;\n  pref_manager_->CacheKMeanColor(account_id_1, k_means_color);\n\n  // Set a wallpaper for account 2.\n  WallpaperInfo info2 = InfoWithType(WallpaperType::kDefault);\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_2, info2));\n\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Show wallpaper for account 1.\n  controller_->ShowUserWallpaper(account_id_1,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n\n  // Verify that we can retrieve the prominent color.\n  EXPECT_EQ(SK_ColorGREEN, controller_->GetProminentColor(\n                               {color_utils::LumaRange::DARK,\n                                color_utils::SaturationRange::VIBRANT}));\n\n  // Show wallpaper for account 2.\n  controller_->ShowUserWallpaper(account_id_2,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n  // Since account 2 has not cached colors, the prominent color should be\n  // invalid.\n  EXPECT_EQ(\n      kInvalidWallpaperColor,\n      controller_->GetProminentColor({color_utils::LumaRange::DARK,\n                                      color_utils::SaturationRange::VIBRANT}));\n  EXPECT_EQ(2, observer.colors_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaperFromDataSavesFile) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // Verify that there's no offline wallpaper available in the beginning.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_TRUE(url_list.empty());\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n\n  // Set an online wallpaper with image data.\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n\n  // Verify that the wallpaper with |url| is available offline, and the returned\n  // file name should not contain the small wallpaper suffix.\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_EQ(1U, url_list.size());\n        EXPECT_EQ(GURL(kDummyUrl).ExtractFileName(), url_list[0]);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdatePrimaryUserWallpaperWhileSecondUserActive) {\n  SetBypassDecode();\n  WallpaperInfo wallpaper_info;\n\n  SimulateUserLogin(account_id_1);\n\n  // Set an online wallpaper with image data. Verify that the wallpaper is set\n  // successfully.\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  // Verify that the user wallpaper info is updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Log in |kUser2|, and set another online wallpaper for |kUser1|. Verify that\n  // the on-screen wallpaper doesn't change since |kUser1| is not active, but\n  // wallpaper info is updated properly.\n  SimulateUserLogin(account_id_2);\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& new_params = OnlineWallpaperParams(\n      account_id_1, kAssetId2, GURL(kDummyUrl2),\n      /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId2,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      new_params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info_2(new_params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info_2);\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaper) {\n  SetBypassDecode();\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER_CROPPED;\n  SimulateUserLogin(account_id_1);\n\n  // Verify that calling |SetOnlineWallpaper| will download the image data if it\n  // does not exist. Verify that the wallpaper is set successfully.\n  auto run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaper(\n      params, base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  // Verify that the user wallpaper info is updated.\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  // Verify that wallpaper & collection metrics are logged.\n  histogram_tester().ExpectBucketCount(\"Ash.Wallpaper.Image\", kUnitId, 1);\n  histogram_tester().ExpectBucketCount(\n      \"Ash.Wallpaper.Collection\",\n      static_cast<int>(base::PersistentHash(\n          TestWallpaperControllerClient::kDummyCollectionId)),\n      1);\n  histogram_tester().ExpectBucketCount(\"Ash.Wallpaper.Type\",\n                                       WallpaperType::kOnline, 1);\n\n  // Verify that the wallpaper with |url| is available offline, and the returned\n  // file name should not contain the small wallpaper suffix.\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_EQ(1U, url_list.size());\n        EXPECT_EQ(GURL(kDummyUrl).ExtractFileName(), url_list[0]);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n}\n\nTEST_F(WallpaperControllerTest, SetAndRemovePolicyWallpaper) {\n  SetBypassDecode();\n  // Simulate the login screen.\n  ClearLogin();\n\n  // The user starts with no wallpaper info and is not controlled by policy.\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // A default wallpaper is shown for the user.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n\n  // Set a policy wallpaper. Verify that the user becomes policy controlled and\n  // the wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_1)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Verify the wallpaper is not updated since the user hasn't logged in.\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Log in the user. Verify the policy wallpaper is now being shown.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Clear the wallpaper and log out the user. Verify the policy wallpaper is\n  // shown in the login screen.\n  ClearWallpaper();\n  ClearLogin();\n  controller_->ClearPrefChangeObserverForTesting();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Remove the policy wallpaper. Verify the wallpaper info is reset to default\n  // and the user is no longer policy controlled.\n  ClearWallpaperCount();\n  controller_->RemovePolicyWallpaper(account_id_1);\n  WaitUntilCustomWallpapersDeleted(account_id_1);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Verify the wallpaper is not updated since the user hasn't logged in (to\n  // avoid abrupt wallpaper change in login screen).\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Log in the user. Verify the default wallpaper is now being shown.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n}\n\n// Simulates the scenario where the wallpaper are not yet resized and only the\n// original size image is available.\nTEST_F(WallpaperControllerTest, ShowUserWallpaper_OriginalFallback) {\n  SetBypassDecode();\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen.\n  ClearLogin();\n\n  // Set a wallpaper.\n  CreateAndSaveWallpapers(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was set.\n  WallpaperInfo wallpaper_info;\n  ASSERT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  ASSERT_EQ(WallpaperType::kCustomized, wallpaper_info.type);\n  ASSERT_EQ(\"user1@test.com-hash/user1@test.com-file\", wallpaper_info.location);\n\n  // Move the wallpaper file to the original folder.\n  base::FilePath saved_wallpaper = custom_wallpaper_dir_.GetPath().Append(\n      \"small/user1@test.com-hash/user1@test.com-file\");\n  ASSERT_TRUE(base::PathExists(saved_wallpaper));\n  base::CreateDirectory(\n      WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")\n          .Append(\"user1@test.com-hash\"));\n  ASSERT_TRUE(base::PathExists(\n      WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")));\n  ASSERT_TRUE(\n      base::Move(saved_wallpaper,\n                 WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")\n                     .Append(wallpaper_info.location)));\n  ASSERT_FALSE(base::PathExists(saved_wallpaper));\n  ClearDecodeFilePaths();\n\n  // Show wallpaper\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was found in the original folder.\n  EXPECT_FALSE(GetDecodeFilePaths().empty());\n  EXPECT_THAT(\n      GetDecodeFilePaths().back().value(),\n      testing::EndsWith(\"original/user1@test.com-hash/user1@test.com-file\"));\n}\n\n// Simulates a missing wallpaper due (possibly) an outdated preference. In this\n// situation, we fallback to the default.\nTEST_F(WallpaperControllerTest, ShowUserWallpaper_MissingFile) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen.\n  ClearLogin();\n\n  // Set a wallpaper.\n  CreateAndSaveWallpapers(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was set.\n  WallpaperInfo wallpaper_info;\n  ASSERT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  ASSERT_EQ(WallpaperType::kCustomized, wallpaper_info.type);\n  ASSERT_EQ(\"user1@test.com-hash/user1@test.com-file\", wallpaper_info.location);\n\n  // Delete wallpaper file.\n  EXPECT_TRUE(base::DeleteFile(\n      user_data_dir_.GetPath().Append(wallpaper_info.location)));\n  ClearDecodeFilePaths();\n\n  // Show wallpaper\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the default wallpaper was used because the stored wallpaper was\n  // missing.\n  EXPECT_FALSE(GetDecodeFilePaths().empty());\n  EXPECT_THAT(GetDecodeFilePaths().back().value(),\n              testing::EndsWith(kDefaultSmallWallpaperName));\n}\n\nTEST_F(WallpaperControllerTest, RemovePolicyWallpaperNoOp) {\n  auto verify_custom_wallpaper_info = [&]() {\n    EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n    EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n\n    WallpaperInfo wallpaper_info;\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    WallpaperInfo expected_wallpaper_info(\n        base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(),\n        WALLPAPER_LAYOUT_CENTER, WallpaperType::kCustomized,\n        base::Time::Now().LocalMidnight());\n    EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n  };\n\n  // Set a custom wallpaper. Verify the user is not policy controlled and the\n  // wallpaper info is correct.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(\n      account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER,\n      CreateImage(640, 480, kWallpaperColor), false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  verify_custom_wallpaper_info();\n\n  // Verify RemovePolicyWallpaper() is a no-op when the user doesn't have a\n  // policy wallpaper.\n  controller_->RemovePolicyWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  verify_custom_wallpaper_info();\n}\n\nTEST_F(WallpaperControllerTest, SetThirdPartyWallpaper) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // Verify the user starts with no wallpaper info.\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Set a third-party wallpaper for |kUser1|.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia third_party_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  ClearWallpaperCount();\n  EXPECT_TRUE(controller_->SetThirdPartyWallpaper(\n      account_id_1, file_name_1, layout, third_party_wallpaper));\n  RunAllTasksUntilIdle();\n  // Verify the wallpaper is shown.\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Verify the user wallpaper info is updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n\n  // Switch active user to |kUser2|, but set another third-party wallpaper for\n  // |kUser1|; the operation should not be allowed, because |kUser1| is not the\n  // active user.\n  SimulateUserLogin(account_id_2);\n  ClearWallpaperCount();\n  EXPECT_FALSE(controller_->SetThirdPartyWallpaper(\n      account_id_1, file_name_2, layout, third_party_wallpaper));\n  // Verify the wallpaper is not shown.\n  EXPECT_EQ(0, GetWallpaperCount());\n  // Verify the wallpaper info for |kUser1| is updated, because setting\n  // wallpaper is still allowed for non-active users.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info_2(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_2).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info_2);\n\n  // Set a policy wallpaper for |kUser2|. Verify that |kUser2| becomes policy\n  // controlled.\n  controller_->SetPolicyWallpaper(account_id_2, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_2));\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Setting a third-party wallpaper for |kUser2| should not be allowed, because\n  // third-party wallpapers cannot be set for policy controlled users.\n  ClearWallpaperCount();\n  EXPECT_FALSE(controller_->SetThirdPartyWallpaper(\n      account_id_2, file_name_1, layout, third_party_wallpaper));\n  // Verify the wallpaper is not shown.\n  EXPECT_EQ(0, GetWallpaperCount());\n  // Verify |kUser2| is still policy controlled and has the policy wallpaper\n  // info.\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_2));\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_2, &wallpaper_info));\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_2)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForRegularAccount) {\n  CreateDefaultWallpapers();\n  SimulateUserLogin(account_id_1);\n\n  // First, simulate setting a user custom wallpaper.\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_NE(wallpaper_info.type, default_wallpaper_info.type);\n\n  // Verify |SetDefaultWallpaper| removes the previously set custom wallpaper\n  // info, and the large default wallpaper is set successfully with the correct\n  // file path.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n\n  SimulateSettingCustomWallpaper(account_id_1);\n  // Verify |SetDefaultWallpaper| removes the previously set custom wallpaper\n  // info, and the small default wallpaper is set successfully with the correct\n  // file path.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n\n  SimulateSettingCustomWallpaper(account_id_1);\n  // Verify that when screen is rotated, |SetDefaultWallpaper| removes the\n  // previously set custom wallpaper info, and the small default wallpaper is\n  // set successfully with the correct file path.\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForChildAccount) {\n  CreateDefaultWallpapers();\n\n  SimulateUserLogin(kChildAccountId, user_manager::USER_TYPE_CHILD);\n\n  // Verify the large child wallpaper is set successfully with the correct file\n  // path.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(kChildAccountId, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kChildLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  // Verify the small child wallpaper is set successfully with the correct file\n  // path.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(kChildAccountId, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kChildSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\n// Verify that the |ShowWallpaperImage| will be called with the default image\n// for the guest session only even if there's a policy that has been set for\n// another user which invokes |SetPolicyWallpaper|.\nTEST_F(WallpaperControllerTest,\n       SetDefaultWallpaperForGuestSessionUnaffectedByWallpaperPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen.\n  ClearLogin();\n  CreateDefaultWallpapers();\n  ClearWallpaperCount();\n\n  // First, simulate settings for a guest user which will show the default\n  // wallpaper image by invoking |ShowWallpaperImage|.\n  SimulateGuestLogin();\n\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n\n  const AccountId guest_id =\n      AccountId::FromUserEmail(user_manager::kGuestUserName);\n  SimulateUserLogin(guest_id, user_manager::USER_TYPE_GUEST);\n  controller_->SetDefaultWallpaper(guest_id, /*show_wallpaper=*/true,\n                                   base::DoNothing());\n\n  WallpaperInfo wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  // Verify that the current displayed wallpaper is the default one inside the\n  // guest session.\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  // Second, set a user policy for which is being set for another\n  // user and verifying that the policy has been applied successfully.\n  WallpaperInfo policy_wallpaper_info;\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  /*data=*/std::string());\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                  &policy_wallpaper_info));\n  WallpaperInfo expected_policy_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1)\n          .Append(\"policy-controlled.jpeg\")\n          .value(),\n      WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kPolicy,\n      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(policy_wallpaper_info, expected_policy_wallpaper_info);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  // Finally, verifying that the guest session hasn't been affected by the new\n  // policy and |ShowWallpaperImage| hasn't been invoked another time.\n\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForGuestSession) {\n  CreateDefaultWallpapers();\n\n  // First, simulate setting a custom wallpaper for a regular user.\n  SimulateUserLogin(account_id_1);\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_NE(wallpaper_info.type, default_wallpaper_info.type);\n\n  const AccountId guest_id =\n      AccountId::FromUserEmail(user_manager::kGuestUserName);\n  SimulateUserLogin(guest_id, user_manager::USER_TYPE_GUEST);\n\n  // Verify that during a guest session, |SetDefaultWallpaper| removes the user\n  // custom wallpaper info, but a guest specific wallpaper should be set,\n  // instead of the regular default wallpaper.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(guest_id, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(guest_id, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperCallbackTiming) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // First, simulate setting a user custom wallpaper.\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_NE(wallpaper_info.type, WallpaperType::kDefault);\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set default wallpaper and wait for success callback.\n  base::RunLoop loop;\n  controller_->SetDefaultWallpaper(\n      account_id_1, /*show_wallpaper=*/true,\n      base::BindLambdaForTesting([&loop, &observer](bool success) {\n        ASSERT_TRUE(success);\n        // Success callback should run before wallpaper observer is notified of\n        // change.\n        ASSERT_EQ(0, observer.wallpaper_changed_count());\n        loop.Quit();\n      }));\n  loop.Run();\n  // Wallpaper observer should have been notified of wallpaper change.\n  EXPECT_EQ(1, observer.wallpaper_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, IgnoreWallpaperRequestInKioskMode) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(\"kiosk\", user_manager::USER_TYPE_KIOSK_APP);\n\n  // Verify that |SetCustomWallpaper| doesn't set wallpaper in kiosk mode, and\n  // |account_id_1|'s wallpaper info is not updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Verify that |SetOnlineWallpaperFromData| doesn't set wallpaper in kiosk\n  // mode, and |account_id_1|'s wallpaper info is not updated.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_FALSE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Verify that |SetDefaultWallpaper| doesn't set wallpaper in kiosk mode, and\n  // |account_id_1|'s wallpaper info is not updated.\n  ClearWallpaperCount();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n}\n\n// Disable the wallpaper setting for public session since it is ephemeral.\nTEST_F(WallpaperControllerTest, NotShowWallpaperSettingInPublicSession) {\n  SimulateUserLogin(\"public_session\", user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n  EXPECT_FALSE(controller_->ShouldShowWallpaperSetting());\n}\n\nTEST_F(WallpaperControllerTest, IgnoreWallpaperRequestWhenPolicyIsEnforced) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // Set a policy wallpaper for the user. Verify the user is policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  WallpaperInfo wallpaper_info;\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_1)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n\n  {\n    // Verify that |SetCustomWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                    WALLPAPER_LAYOUT_CENTER, image,\n                                    false /*preview_mode=*/);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetCustomWallpaper| with callback doesn't set wallpaper when\n    // policy is enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(\n        account_id_1, base::FilePath(file_name_1), WALLPAPER_LAYOUT_CENTER,\n        /*preview_mode=*/false,\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetOnlineWallpaperFromData| doesn't set wallpaper when\n    // policy is enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaperFromData(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(kDummyUrl),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        /*image_data=*/std::string(),\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetOnlineWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaper(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(kDummyUrl),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetDefaultWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    ClearWallpaperCount();\n    controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                     base::DoNothing());\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n}\n\nTEST_F(WallpaperControllerTest, VerifyWallpaperCache) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // |kUser1| doesn't have wallpaper cache in the beginning.\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetOnlineWallpaperFromData| updates wallpaper cache for |user1|.\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // After |kUser2| is logged in, |user1|'s wallpaper cache should still be kept\n  // (crbug.com/339576). Note the active user is still |user1|.\n  TestSessionControllerClient* session = GetSessionControllerClient();\n  session->AddUserSession(kUser2);\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetDefaultWallpaper| clears wallpaper cache.\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetCustomWallpaper| updates wallpaper cache for |user1|.\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |RemoveUserWallpaper| clears wallpaper cache.\n  controller_->RemoveUserWallpaper(account_id_1);\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n}\n\n// Tests that the appropriate wallpaper (large vs. small) is shown depending\n// on the desktop resolution.\nTEST_F(WallpaperControllerTest, ShowCustomWallpaperWithCorrectResolution) {\n  CreateDefaultWallpapers();\n  const base::FilePath small_custom_wallpaper_path =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  const base::FilePath large_custom_wallpaper_path =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kLargeWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  const base::FilePath small_default_wallpaper_path =\n      default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName);\n  const base::FilePath large_default_wallpaper_path =\n      default_wallpaper_dir_.GetPath().Append(kDefaultLargeWallpaperName);\n\n  CreateAndSaveWallpapers(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  // Display is initialized to 800x600. The small resolution custom wallpaper is\n  // expected. A second decode request with small resolution default wallpaper\n  // is also expected. (Because unit tests don't support actual wallpaper\n  // decoding, it falls back to the default wallpaper.)\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(small_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(small_default_wallpaper_path, GetDecodeFilePaths()[1]);\n\n  // Hook up another 800x600 display. This shouldn't trigger a reload.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,800x600\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(0u, GetDecodeFilePaths().size());\n\n  // Detach the secondary display.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  // Hook up a 2000x2000 display. The large resolution custom wallpaper should\n  // be loaded.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,3000x2000\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(large_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(large_default_wallpaper_path, GetDecodeFilePaths()[1]);\n\n  // Detach the secondary display.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  // Hook up the 3000x2000 display again. The large resolution default wallpaper\n  // should persist. Test for crbug/165788.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,3000x2000\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(large_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(large_default_wallpaper_path, GetDecodeFilePaths()[1]);\n}\n\n// After the display is rotated, the sign in wallpaper should be kept. Test for\n// crbug.com/794725.\nTEST_F(WallpaperControllerTest, SigninWallpaperIsKeptAfterRotation) {\n  CreateDefaultWallpapers();\n\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  // Display is initialized to 800x600. The small resolution default wallpaper\n  // is expected.\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  // After rotating the display, the small resolution default wallpaper should\n  // still be expected, instead of a custom wallpaper.\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\n// Display size change should trigger wallpaper reload.\nTEST_F(WallpaperControllerTest, ReloadWallpaper) {\n  CreateAndSaveWallpapers(account_id_1);\n\n  // Show a user wallpaper.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Calling |ShowUserWallpaper| again with the same account id and display\n  // size should not trigger wallpaper reload (crbug.com/158383).\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Start wallpaper preview.\n  SimulateUserLogin(account_id_1);\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(\n      account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER,\n      CreateImage(640, 480, kWallpaperColor), true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show an always-on-top wallpaper.\n  const base::FilePath image_path =\n      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(\n          switches::kGuestWallpaperLarge);\n  CreateDefaultWallpapers();\n  SetBypassDecode();\n  ClearWallpaperCount();\n  controller_->ShowAlwaysOnTopWallpaper(image_path);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, UpdateCurrentWallpaperLayout) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kSmallCustomWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  WallpaperLayout new_layout = WALLPAPER_LAYOUT_CENTER;\n  SimulateUserLogin(account_id_1);\n\n  // Set a custom wallpaper for the user. Verify that it's set successfully\n  // and the wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_custom_wallpaper_info);\n\n  // Now change to a different layout. Verify that the layout is updated for\n  // both the current wallpaper and the saved wallpaper info.\n  ClearWallpaperCount();\n  controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), new_layout);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  expected_custom_wallpaper_info.layout = new_layout;\n  EXPECT_EQ(wallpaper_info, expected_custom_wallpaper_info);\n\n  {\n    base::test::ScopedFeatureList scoped_feature_list;\n    scoped_feature_list.InitWithFeatures(\n        {ash::features::kWallpaperGooglePhotosIntegration}, {});\n\n    // Now set a Google Photos wallpaper. Verify that it's set successfully and\n    // the wallpaper info is updated.\n    ClearWallpaperCount();\n    controller_->SetGooglePhotosWallpaper(\n        GooglePhotosWallpaperParams(account_id_1, \"id\",\n                                    /*daily_refresh_enabled=*/false, layout,\n                                    /*preview_mode=*/false, \"dedup_key\"),\n        base::DoNothing());\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(1, GetWallpaperCount());\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n    EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info,\n              WallpaperInfo(GooglePhotosWallpaperParams(\n                  account_id_1, \"id\", /*daily_refresh_enabled=*/false, layout,\n                  /*preview_mode=*/false, \"dedup_key\")));\n\n    // Now change to a different layout. Verify that the layout is updated for\n    // both the current wallpaper and the saved wallpaper info.\n    ClearWallpaperCount();\n    controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(1, GetWallpaperCount());\n    EXPECT_EQ(controller_->GetWallpaperLayout(), new_layout);\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info,\n              WallpaperInfo(GooglePhotosWallpaperParams(\n                  account_id_1, \"id\", /*daily_refresh_enabled=*/false,\n                  new_layout, /*preview_mode=*/false, \"dedup_key\")));\n  }\n\n  // Now set an online wallpaper. Verify that it's set successfully and the\n  // wallpaper info is updated.\n  image = CreateImage(640, 480, kWallpaperColor);\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(), layout,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_online_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_online_wallpaper_info);\n\n  // Now change the layout of the online wallpaper. Verify that it's a no-op.\n  ClearWallpaperCount();\n  controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n  RunAllTasksUntilIdle();\n  // The wallpaper is not updated.\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  // The saved wallpaper info is not updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, expected_online_wallpaper_info);\n}\n\n// Tests that if a user who has a custom wallpaper is removed from the device,\n// only the directory that contains the user's custom wallpapers gets removed.\n// The other user's custom wallpaper is not affected.\nTEST_F(WallpaperControllerTest, RemoveUserWithCustomWallpaper) {\n  SimulateUserLogin(account_id_1);\n  base::FilePath small_wallpaper_path_1 =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n\n  // Set a custom wallpaper for |kUser1| and verify the wallpaper exists.\n  CreateAndSaveWallpapers(account_id_1);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n\n  // Now login another user and set a custom wallpaper for the user.\n  SimulateUserLogin(account_id_2);\n  base::FilePath small_wallpaper_path_2 = GetCustomWallpaperPath(\n      WallpaperControllerImpl::kSmallWallpaperSubDir, wallpaper_files_id_2,\n      GetDummyFileName(account_id_2));\n  CreateAndSaveWallpapers(account_id_2);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_2));\n\n  // Simulate the removal of |kUser2|.\n  controller_->RemoveUserWallpaper(account_id_2);\n  // Wait until all files under the user's custom wallpaper directory are\n  // removed.\n  WaitUntilCustomWallpapersDeleted(account_id_2);\n  EXPECT_FALSE(base::PathExists(small_wallpaper_path_2));\n\n  // Verify that the other user's wallpaper is not affected.\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n}\n\n// Tests that if a user who has a default wallpaper is removed from the device,\n// the other user's custom wallpaper is not affected.\nTEST_F(WallpaperControllerTest, RemoveUserWithDefaultWallpaper) {\n  SimulateUserLogin(account_id_1);\n  base::FilePath small_wallpaper_path_1 =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  // Set a custom wallpaper for |kUser1| and verify the wallpaper exists.\n  CreateAndSaveWallpapers(account_id_1);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n\n  // Now login another user and set a default wallpaper for the user.\n  SimulateUserLogin(account_id_2);\n  controller_->SetDefaultWallpaper(account_id_2, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n\n  // Simulate the removal of |kUser2|.\n  controller_->RemoveUserWallpaper(account_id_2);\n\n  // Verify that the other user's wallpaper is not affected.\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n}\n\nTEST_F(WallpaperControllerTest, IsActiveUserWallpaperControlledByPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen. Verify that it returns false since there's no\n  // active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  SimulateUserLogin(account_id_1);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n  // Set a policy wallpaper for the active user. Verify that the active user\n  // becomes policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Switch the active user. Verify the active user is not policy controlled.\n  SimulateUserLogin(account_id_2);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Logs out. Verify that it returns false since there's no active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n}\n\nTEST_F(WallpaperControllerTest,\n       IsManagedGuestSessionWallpaperControlledByPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen. Verify that it returns false since there's no\n  // active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Set a policy wallpaper for the managed guest session. Verify that the\n  // managed guest session becomes policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1,\n                                  user_manager::USER_TYPE_PUBLIC_ACCOUNT,\n                                  std::string() /*data=*/);\n  SimulateUserLogin(account_id_1, user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  // Verify the wallpaper policy is applied after logging in.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Switch the active user. Verify the active user is not policy controlled.\n  SimulateUserLogin(account_id_2);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Logs out. Verify that it returns false since there's no active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperBlur) {\n  TestWallpaperControllerObserver observer(controller_);\n\n  ASSERT_TRUE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(0, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(1, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(2, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  // Blur state does not change below.\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  SetSessionState(SessionState::OOBE);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  SetSessionState(SessionState::UNKNOWN);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperBlurDuringLockScreenTransition) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  gfx::ImageSkia image = CreateImage(600, 400, kWallpaperColor);\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  ASSERT_TRUE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n\n  // Simulate lock and unlock sequence.\n  controller_->UpdateWallpaperBlurForLockState(true);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(1, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  ASSERT_EQ(3u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_SOLID_COLOR,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[2]->type());\n\n  // Change of state to ACTIVE triggers post lock animation and\n  // UpdateWallpaperBlur(false)\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(2, observer.blur_changed_count());\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n}\n\nTEST_F(WallpaperControllerTest, LockDuringOverview) {\n  gfx::ImageSkia image = CreateImage(600, 400, kWallpaperColor);\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  TestWallpaperControllerObserver observer(controller_);\n\n  EnterOverview();\n\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(0, observer.blur_changed_count());\n\n  // Simulate lock and unlock sequence.\n  SetSessionState(SessionState::LOCKED);\n\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n\n  // Get wallpaper_view directly because it's not animating.\n  auto* wallpaper_view = Shell::Get()\n                             ->GetPrimaryRootWindowController()\n                             ->wallpaper_widget_controller()\n                             ->wallpaper_view();\n\n  // Make sure that wallpaper still have blur.\n  ASSERT_EQ(30, wallpaper_view->blur_sigma());\n}\n\nTEST_F(WallpaperControllerTest, DontLeakShieldView) {\n  SetSessionState(SessionState::LOCKED);\n  views::View* shield_view = wallpaper_view()->shield_view_for_testing();\n  ASSERT_TRUE(shield_view);\n  views::ViewTracker view_tracker(shield_view);\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_EQ(nullptr, wallpaper_view()->shield_view_for_testing());\n  EXPECT_EQ(nullptr, view_tracker.view());\n}\n\nTEST_F(WallpaperControllerTest, OnlyShowDevicePolicyWallpaperOnLoginScreen) {\n  SetBypassDecode();\n\n  // Verify the device policy wallpaper is shown on login screen.\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  controller_->SetDevicePolicyWallpaperPath(\n      base::FilePath(kDefaultSmallWallpaperName));\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_TRUE(IsDevicePolicyWallpaper());\n  // Verify the device policy wallpaper shouldn't be blurred.\n  ASSERT_FALSE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  // Verify the device policy wallpaper is replaced when session state is no\n  // longer LOGIN_PRIMARY.\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  // Verify the device policy wallpaper never shows up again when session\n  // state changes.\n  SetSessionState(SessionState::ACTIVE);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  SetSessionState(SessionState::LOCKED);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n}\n\nTEST_F(WallpaperControllerTest, ShouldShowInitialAnimationAfterBoot) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen after system boot.\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(\n      switches::kFirstExecAfterBoot);\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(switches::kLoginManager);\n  ClearLogin();\n\n  // Show the first wallpaper. Verify that the slower animation should be used.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show the second wallpaper. Verify that the slower animation should not be\n  // used. (Use a different user type to ensure a different wallpaper is shown,\n  // otherwise requests of loading the same wallpaper are ignored.)\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(kChildAccountId);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Log in the user and show the wallpaper. Verify that the slower animation\n  // should not be used.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, ShouldNotShowInitialAnimationAfterSignOut) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen after user sign-out. Verify that the slower\n  // animation should never be used.\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(switches::kLoginManager);\n  CreateAndSaveWallpapers(account_id_1);\n  ClearLogin();\n\n  // Show the first wallpaper.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show the second wallpaper.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(kChildAccountId);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Log in the user and show the wallpaper.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, ClosePreviewWallpaperOnOverviewStart) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n\n  TestWallpaperControllerObserver observer(controller_);\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now enter overview mode. Verify the wallpaper changes back to the default,\n  // the user wallpaper info remains unchanged, and enters overview mode\n  // properly.\n  ClearWallpaperCount();\n  EnterOverview();\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  EXPECT_TRUE(Shell::Get()->overview_controller()->InOverviewSession());\n}\n\nTEST_F(WallpaperControllerTest, ClosePreviewWallpaperOnWindowCycleStart) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now start window cycle. Verify the wallpaper changes back to the default,\n  // the user wallpaper info remains unchanged, and enters window cycle.\n  ClearWallpaperCount();\n  Shell::Get()->window_cycle_controller()->HandleCycleWindow(\n      WindowCycleController::WindowCyclingDirection::kForward);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  EXPECT_TRUE(Shell::Get()->window_cycle_controller()->IsCycling());\n}\n\nTEST_F(WallpaperControllerTest,\n       ClosePreviewWallpaperOnActiveUserSessionChanged) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now switch to another user. Verify the wallpaper changes back to the\n  // default and the user wallpaper remains unchanged.\n  ClearWallpaperCount();\n  SimulateUserLogin(account_id_2);\n  controller_->ShowUserWallpaper(account_id_2);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_2, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, ConfirmPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\", 1);\n\n  // Now confirm the preview wallpaper, verify that there's no wallpaper change\n  // because the wallpaper is already shown.\n  ClearWallpaperCount();\n  controller_->ConfirmPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n\n  // Verify that the user wallpaper info is now updated to the custom wallpaper\n  // info.\n  WallpaperInfo custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, custom_wallpaper_info);\n\n  // Set an empty online wallpaper for the user, verify it fails.\n  ClearWallpaperCount();\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, gfx::ImageSkia(), kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_FALSE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Now set a valid online wallpaper for the user and enable preview. Verify\n  // that the wallpaper is changed to the expected color.\n  const SkColor online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia online_wallpaper =\n      CreateImage(640, 480, online_wallpaper_color);\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  run_loop = std::make_unique<base::RunLoop>();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/\n      std::vector<OnlineWallpaperVariant>(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, custom_wallpaper_info);\n\n  // Now confirm the preview wallpaper, verify that there's no wallpaper change\n  // because the wallpaper is already shown.\n  ClearWallpaperCount();\n  controller_->ConfirmPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info is now updated to the online wallpaper\n  // info.\n  WallpaperInfo online_wallpaper_info(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false,\n      /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/\n      std::vector<OnlineWallpaperVariant>()));\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, online_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, CancelPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now cancel the preview. Verify the wallpaper changes back to the default\n  // and the user wallpaper info remains unchanged.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now set an online wallpaper for the user and enable preview. Verify that\n  // the wallpaper is changed to the expected color.\n  const SkColor online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia online_wallpaper =\n      CreateImage(640, 480, online_wallpaper_color);\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now cancel the preview. Verify the wallpaper changes back to the default\n  // and the user wallpaper info remains unchanged.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, WallpaperSyncedDuringPreview) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now set another custom wallpaper for the user and disable preview (this\n  // happens if a custom wallpaper set on another device is being synced).\n  // Verify there's no wallpaper change since preview mode shouldn't be\n  // interrupted.\n  const SkColor synced_custom_wallpaper_color = SK_ColorBLUE;\n  gfx::ImageSkia synced_custom_wallpaper =\n      CreateImage(640, 480, synced_custom_wallpaper_color);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_2, layout,\n                                  synced_custom_wallpaper,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // However, the user wallpaper info should already be updated to the new info.\n  WallpaperInfo synced_custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_2).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Now cancel the preview. Verify the synced custom wallpaper is shown instead\n  // of the initial default wallpaper, and the user wallpaper info is still\n  // correct.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(synced_custom_wallpaper_color, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Repeat the above steps for online wallpapers: set a online wallpaper for\n  // the user and enable preview. Verify that the wallpaper is changed to the\n  // expected color.\n  gfx::ImageSkia online_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Now set another online wallpaper for the user and disable preview. Verify\n  // there's no wallpaper change since preview mode shouldn't be interrupted.\n  const SkColor synced_online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia synced_online_wallpaper =\n      CreateImage(640, 480, synced_online_wallpaper_color);\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, synced_online_wallpaper, kDummyUrl2,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/false,\n      /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // However, the user wallpaper info should already be updated to the new info.\n  WallpaperInfo synced_online_wallpaper_info =\n      WallpaperInfo(OnlineWallpaperParams(\n          account_id_1, kAssetId, GURL(kDummyUrl2),\n          TestWallpaperControllerClient::kDummyCollectionId, layout,\n          /*preview_mode=*/false,\n          /*from_user=*/true,\n          /*daily_refresh_enabled=*/false, kUnitId,\n          /*variants=*/\n          std::vector<OnlineWallpaperVariant>()));\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_online_wallpaper_info);\n\n  // Now cancel the preview. Verify the synced online wallpaper is shown instead\n  // of the previous custom wallpaper, and the user wallpaper info is still\n  // correct.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(synced_online_wallpaper_color, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_online_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, AddFirstWallpaperAnimationEndCallback) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n  std::unique_ptr<aura::Window> test_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n\n  base::RunLoop test_loop;\n  controller_->AddFirstWallpaperAnimationEndCallback(test_loop.QuitClosure(),\n                                                     test_window.get());\n  // The callback is not run because the first wallpaper hasn't been set.\n  task_environment()->RunUntilIdle();\n  EXPECT_FALSE(test_loop.AnyQuitCalled());\n\n  // Set the first wallpaper.\n  controller_->ShowDefaultWallpaperForTesting();\n  controller_->AddFirstWallpaperAnimationEndCallback(test_loop.QuitClosure(),\n                                                     test_window.get());\n  task_environment()->RunUntilIdle();\n  // Neither callback is run because the animation of the first wallpaper\n  // hasn't finished yet.\n  EXPECT_FALSE(test_loop.AnyQuitCalled());\n\n  // Force the animation to complete. The two callbacks are both run.\n  RunDesktopControllerAnimation();\n  test_loop.Run();\n  EXPECT_TRUE(test_loop.AnyQuitCalled());\n\n  // The callback added after the first wallpaper animation is run right away.\n  bool is_third_callback_run = false;\n  controller_->AddFirstWallpaperAnimationEndCallback(\n      base::BindLambdaForTesting(\n          [&is_third_callback_run]() { is_third_callback_run = true; }),\n      test_window.get());\n  EXPECT_TRUE(is_third_callback_run);\n}\n\nTEST_F(WallpaperControllerTest, ShowOneShotWallpaper) {\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n  // First, set a custom wallpaper for |kUser1|. Verify the wallpaper is shown\n  // successfully and the user wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  const WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n\n  // Show a one-shot wallpaper. Verify it is shown successfully.\n  ClearWallpaperCount();\n  constexpr SkColor kOneShotWallpaperColor = SK_ColorWHITE;\n  gfx::ImageSkia one_shot_wallpaper =\n      CreateImage(640, 480, kOneShotWallpaperColor);\n  controller_->ShowOneShotWallpaper(one_shot_wallpaper);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kOneShotWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kOneShot, controller_->GetWallpaperType());\n  EXPECT_FALSE(controller_->IsBlurAllowedForLockState());\n  EXPECT_FALSE(controller_->ShouldApplyShield());\n\n  // Verify that we can reload wallpaer without losing it.\n  // This is important for screen rotation.\n  controller_->ReloadWallpaperForTesting(/*clear_cache=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());  // Reload increments count.\n  EXPECT_EQ(kOneShotWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kOneShot, controller_->GetWallpaperType());\n  EXPECT_FALSE(controller_->IsBlurAllowedForLockState());\n  EXPECT_FALSE(controller_->ShouldApplyShield());\n\n  // Verify the user wallpaper info is unaffected, and the one-shot wallpaper\n  // can be replaced by the user wallpaper.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n}\n\nTEST_F(WallpaperControllerTest, OnFirstWallpaperShown) {\n  TestWallpaperControllerObserver observer(controller_);\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(0, observer.first_shown_count());\n  // Show the first wallpaper, verify the observer is notified.\n  controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorBLUE),\n                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n                                  /*preview_mode=*/false,\n                                  /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(SK_ColorBLUE, GetWallpaperColor());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(1, observer.first_shown_count());\n  // Show the second wallpaper, verify the observer is not notified.\n  controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorCYAN),\n                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n                                  /*preview_mode=*/false,\n                                  /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(SK_ColorCYAN, GetWallpaperColor());\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(1, observer.first_shown_count());\n}\n\n// Although ephemeral users' custom wallpapers are not saved to disk, they\n// should be kept within the user session. Test for https://crbug.com/825237.\nTEST_F(WallpaperControllerTest, ShowWallpaperForEphemeralUser) {\n  // Clear the local pref so we can make sure nothing writes to it.\n  local_state()->ClearPref(prefs::kUserWallpaperInfo);\n\n  // Add an ephemeral user session and simulate login, like SimulateUserLogin.\n  UserSession session;\n  session.session_id = 0;\n  session.user_info.account_id = account_id_1;\n  session.user_info.is_ephemeral = true;\n  Shell::Get()->session_controller()->UpdateUserSession(std::move(session));\n  TestSessionControllerClient* const client = GetSessionControllerClient();\n  client->SwitchActiveUser(account_id_1);\n  client->SetSessionState(SessionState::ACTIVE);\n\n  // The user doesn't have wallpaper cache in the beginning.\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER,\n                                  CreateImage(640, 480, kWallpaperColor),\n                                  /*preview_mode=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Assert that we do not use local state for an ephemeral user.\n  auto* dict = local_state()->GetUserPrefValue(prefs::kUserWallpaperInfo);\n  ASSERT_FALSE(dict) << *dict;\n\n  // The custom wallpaper is cached.\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_EQ(\n      kWallpaperColor,\n      cached_wallpaper.GetRepresentation(1.0f).GetBitmap().getColor(0, 0));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Calling |ShowUserWallpaper| will continue showing the custom wallpaper\n  // instead of reverting to the default.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n}\n\nTEST_F(WallpaperControllerTest, AlwaysOnTopWallpaper) {\n  CreateDefaultWallpapers();\n  SetBypassDecode();\n\n  // Show a default wallpaper.\n  EXPECT_EQ(0, GetWallpaperCount());\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Show an always-on-top wallpaper.\n  const base::FilePath image_path =\n      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(\n          switches::kGuestWallpaperLarge);\n  controller_->ShowAlwaysOnTopWallpaper(image_path);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOneShot);\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Subsequent wallpaper requests are ignored when the current wallpaper is\n  // always-on-top.\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOneShot);\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // The wallpaper reverts to the default after the always-on-top wallpaper is\n  // removed.\n  controller_->RemoveAlwaysOnTopWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(3, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Calling |RemoveAlwaysOnTopWallpaper| is a no-op when the current wallpaper\n  // is not always-on-top.\n  controller_->RemoveAlwaysOnTopWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(3, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n}\n\nnamespace {\n\nclass WallpaperControllerPrefTest : public AshTestBase {\n public:\n  WallpaperControllerPrefTest() {\n    base::Value::Dict property;\n    property.Set(\"rotation\", static_cast<int>(display::Display::ROTATE_90));\n    property.Set(\"width\", 800);\n    property.Set(\"height\", 600);\n\n    DictionaryPrefUpdate update(local_state(), prefs::kDisplayProperties);\n    update.Get()->SetKey(\"2200000000\", base::Value(std::move(property)));\n  }\n\n  ~WallpaperControllerPrefTest() override = default;\n\n  void SetUp() override { AshTestBase::SetUp(); }\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\n}  // namespace\n\n// Make sure that the display and the wallpaper view are rotated correctly at\n// startup.\nTEST_F(WallpaperControllerPrefTest, InitWithPrefs) {\n  auto* wallpaper_view = Shell::GetPrimaryRootWindowController()\n                             ->wallpaper_widget_controller()\n                             ->wallpaper_view();\n  auto* root_window =\n      wallpaper_view->GetWidget()->GetNativeWindow()->GetRootWindow();\n\n  EXPECT_EQ(gfx::Size(600, 800), display::Screen::GetScreen()\n                                     ->GetDisplayNearestWindow(root_window)\n                                     .size());\n  EXPECT_EQ(root_window->bounds().size(), wallpaper_view->bounds().size());\n}\n\nTEST_F(WallpaperControllerTest, NoAnimationForNewRootWindowWhenLocked) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n  SetSessionState(SessionState::LOCKED);\n  UpdateDisplay(\"800x600, 800x600\");\n  auto* secondary_root_window_controller =\n      Shell::Get()->GetAllRootWindowControllers()[1];\n  EXPECT_FALSE(secondary_root_window_controller->wallpaper_widget_controller()\n                   ->IsAnimating());\n  EXPECT_FALSE(secondary_root_window_controller->wallpaper_widget_controller()\n                   ->GetWidget()\n                   ->GetLayer()\n                   ->GetAnimator()\n                   ->is_animating());\n}\n\nTEST_F(WallpaperControllerTest, SetCustomWallpaper) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n\n  // Set a custom wallpaper for |kUser1|. Verify the wallpaper is set\n  // successfully and wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n\n  // Now set another custom wallpaper for |kUser1|. Verify that the on-screen\n  // wallpaper doesn't change since |kUser1| is not active, but wallpaper info\n  // is updated properly.\n  SimulateUserLogin(account_id_2);\n  const SkColor custom_wallpaper_color = SK_ColorCYAN;\n  image = CreateImage(640, 480, custom_wallpaper_color);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Verify the updated wallpaper is shown after |kUser1| becomes active again.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(custom_wallpaper_color, GetWallpaperColor());\n}\n\nTEST_F(WallpaperControllerTest, OldOnlineInfoSynced_Discarded) {\n  // Create a dictionary that looks like the preference from crrev.com/a040384.\n  // DO NOT CHANGE as there are preferences like this in production.\n  base::Value::Dict wallpaper_info_dict;\n  wallpaper_info_dict.Set(\n      WallpaperPrefManager::kNewWallpaperDateNodeName,\n      base::NumberToString(\n          base::Time::Now().ToDeltaSinceWindowsEpoch().InMicroseconds()));\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperLocationNodeName,\n                          \"location\");\n  wallpaper_info_dict.Set(\n      WallpaperPrefManager::kNewWallpaperUserFilePathNodeName,\n      \"user_file_path\");\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperLayoutNodeName,\n                          WallpaperLayout::WALLPAPER_LAYOUT_CENTER);\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperTypeNodeName,\n                          static_cast<int>(WallpaperType::kOnline));\n\n  {\n    DictionaryPrefUpdate wallpaper_update(GetProfilePrefService(account_id_1),\n                                          prefs::kSyncableWallpaperInfo);\n    wallpaper_update->SetKey(account_id_1.GetUserEmail(),\n                             base::Value(std::move(wallpaper_info_dict)));\n  }\n  SimulateUserLogin(account_id_1);\n  task_environment()->RunUntilIdle();\n\n  // Unmigrated synced wallpaper info are discarded.\n  WallpaperInfo actual;\n  EXPECT_FALSE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfo_Online) {\n  WallpaperInfo expected_info = InfoWithType(WallpaperType::kOnline);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfoCustomized) {\n  WallpaperInfo expected_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfoDaily) {\n  WallpaperInfo expected_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n  EXPECT_EQ(client_.migrate_collection_id_from_chrome_app_count(), 1u);\n}\n\nTEST_F(WallpaperControllerTest,\n       MigrateWallpaperInfoDoesntHappenWhenSyncedInfoAlreadyExists) {\n  SetBypassDecode();\n\n  WallpaperInfo local_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  WallpaperInfo synced_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId2, GURL(kDummyUrl2),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  // Synced info should be the same if local is the same age.\n  EXPECT_EQ(synced_info, info);\n}\n\nTEST_F(WallpaperControllerTest,\n       ActiveUserPrefServiceChangedSyncedInfoHandledLocally) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  client_.ResetCounts();\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n  RunAllTasksUntilIdle();\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, ActiveUserPrefServiceChanged_SyncDisabled) {\n  CacheOnlineWallpaper(kDummyUrl);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  client_.ResetCounts();\n\n  client_.set_wallpaper_sync_enabled(false);\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kThirdParty, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedLocalIsPolicy) {\n  CacheOnlineWallpaper(kDummyUrl);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1,\n                                       InfoWithType(WallpaperType::kPolicy));\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_NE(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedLocalIsThirdPartyAndOlder) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedLocalIsThirdPartyAndNewer) {\n  CacheOnlineWallpaper(kDummyUrl);\n  pref_manager_->SetLocalWallpaperInfo(\n      account_id_1, InfoWithType(WallpaperType::kThirdParty));\n\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, DayBeforeYesterdayish()};\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kThirdParty, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedOnline) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  // Attempt to set an online wallpaper without providing the image data. Verify\n  // it succeeds this time because |SetOnlineWallpaperFromData| has saved the\n  // file.\n  ClearWallpaperCount();\n  WallpaperInfo info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, info);\n\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedInactiveUser) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  // Make account_id_1 the inactive user.\n  SimulateUserLogin(account_id_2);\n\n  // Attempt to set an online wallpaper without providing the image data. Verify\n  // it succeeds this time because |SetOnlineWallpaperFromData| has saved the\n  // file.\n  ClearWallpaperCount();\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1,\n                                        InfoWithType(WallpaperType::kOnline));\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_NE(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper) {\n  std::string expected{\"fun_collection\"};\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.asset_id = kAssetId;\n  info.collection_id = expected;\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(expected, client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\n// Disabled due to flakes; see crbug/1320991.\nTEST_F(WallpaperControllerTest,\n       DISABLED_UpdateDailyRefreshWallpaperCalledOnLogin) {\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*from_user=*/false,\n      /*daily_refresh_enabled=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>()));\n  info.date = DayBeforeYesterdayish();\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  ClearLogin();\n  SimulateUserLogin(account_id_1);\n\n  // Info is set as over a day old so we expect one task to run in under an hour\n  // (due to fuzzing) then it will idle.\n  task_environment()->FastForwardBy(base::Hours(1));\n\n  EXPECT_EQ(TestWallpaperControllerClient::kDummyCollectionId,\n            client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper_NotEnabled) {\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kOnline, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(std::string(), client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper_NoCollectionId) {\n  SimulateUserLogin(account_id_1);\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kDaily, DayBeforeYesterdayish()));\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(std::string(), client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_TimerStartsOnPrefServiceChange) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily,\n                        base::Time::Now().LocalMidnight()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delta = run_time.ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      Time::Now().LocalMidnight().ToDeltaSinceWindowsEpoch() + base::Days(1);\n\n  ASSERT_GE(delta, update_time - base::Minutes(1));\n  ASSERT_LE(delta, update_time + base::Hours(1) + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_RetryTimerTriggersOnFailedFetchInfo) {\n  using base::Time;\n\n  client_.set_fetch_daily_refresh_info_fails(true);\n\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n  // Lave a little wiggle room.\n  ASSERT_GE(delay, one_hour - base::Minutes(1));\n  ASSERT_LE(delay, one_hour + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_RetryTimerTriggersOnFailedFetchData) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  test_image_downloader_->set_should_fail(true);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n\n  RunAllTasksUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n  // Lave a little wiggle room.\n  ASSERT_GE(delay, one_hour - base::Minutes(1));\n  ASSERT_LE(delay, one_hour + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest, MigrateCustomWallpaper) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  ClearLogin();\n\n  SimulateUserLogin(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_WallpaperIsntCustom) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kOnline);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_TRUE(client_.get_save_wallpaper_to_drive_fs_account_id().empty());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_AlreadySynced) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n\n  client_.ResetCounts();\n\n  // Should not reupload image if it has already been synced.\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_FALSE(client_.get_save_wallpaper_to_drive_fs_account_id().is_valid());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_OldLocalInfo) {\n  WallpaperInfo local_info =\n      WallpaperInfo(\"a_url\", WALLPAPER_LAYOUT_CENTER_CROPPED,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  WallpaperInfo synced_info = WallpaperInfo(\n      \"b_url\", WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kCustomized,\n      base::Time::Now().LocalMidnight());\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_FALSE(client_.get_save_wallpaper_to_drive_fs_account_id().is_valid());\n  // This is called by WallpaperController::HandleCustomWallpaperSyncedIn.\n  EXPECT_EQ(client_.get_wallpaper_path_from_drive_fs_account_id(),\n            account_id_1);\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_NewLocalInfo) {\n  WallpaperInfo local_info = WallpaperInfo(\n      \"a_url\", WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kCustomized,\n      base::Time::Now().LocalMidnight());\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  WallpaperInfo synced_info =\n      WallpaperInfo(\"b_url\", WALLPAPER_LAYOUT_CENTER_CROPPED,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  SimulateUserLogin(account_id_1);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, SetDailyRefreshCollectionId) {\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kOnline, DayBeforeYesterdayish()));\n\n  std::string collection_id = \"fun_collection\";\n  controller_->SetDailyRefreshCollectionId(account_id_1, collection_id);\n  WallpaperInfo expected = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                            WallpaperType::kDaily, DayBeforeYesterdayish()};\n  expected.collection_id = collection_id;\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  // Type should be `WallpaperType::kDaily` now, and collection_id should be\n  // updated.\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(collection_id,\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\nTEST_F(WallpaperControllerTest, SetDailyRefreshCollectionId_Empty) {\n  std::string collection_id = \"fun_collection\";\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = collection_id;\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->SetDailyRefreshCollectionId(account_id_1, std::string());\n  WallpaperInfo expected = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                            WallpaperType::kOnline, DayBeforeYesterdayish()};\n  expected.collection_id = collection_id;\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  // Type should be `WallpaperType::kOnline` now, and collection_id should be\n  // `WallpaperType::EMPTY`.\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(std::string(),\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\n// WallpaperType should not change with an empty collection id if the previous\n// WallpaperType isn't |WallpaperType::kDaily|.\nTEST_F(WallpaperControllerTest,\n       SetDailyRefreshCollectionId_Empty_NotTypeDaily) {\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish()));\n\n  controller_->SetDailyRefreshCollectionId(account_id_1, std::string());\n  WallpaperInfo expected =\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(std::string(),\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\nTEST_F(WallpaperControllerTest, UpdateWallpaperOnColorModeChanged) {\n  SimulateUserLogin(account_id_1);\n\n  auto run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  controller_->SetOnlineWallpaper(\n      params, base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  pref_manager_->SetUserWallpaperInfo(account_id_1, WallpaperInfo(params));\n  Shell::Get()->session_controller()->GetActivePrefService()->SetBoolean(\n      prefs::kDarkModeEnabled, true);\n  controller_->OnColorModeChanged(true);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n\n  WallpaperInfo expected = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId, variants));\n  WallpaperInfo actual;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n  EXPECT_EQ(expected, actual);\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n  // Resets the count as user will start with a default image after login.\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/true, kUnitId, variants);\n  const WallpaperInfo info = WallpaperInfo(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  // Set a new daily wallpaper.\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n  base::TimeDelta one_day = base::Days(1);\n  // Leave a little wiggle room, as well as account for the hour fuzzing that\n  // we do.\n  EXPECT_GE(delay, one_day - base::Minutes(1));\n  EXPECT_LE(delay, one_day + base::Minutes(61));\n\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDaily);\n\n  // Fast forward by one hour and attempt a system's color mode change.\n  task_environment()->FastForwardBy(base::Hours(1));\n  Shell::Get()->dark_light_mode_controller()->ToggleColorMode();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  // Expect the refresh timer doesn't reset.\n  EXPECT_EQ(\n      run_time,\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time());\n\n  WallpaperInfo actual;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n  EXPECT_EQ(info, actual);\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateWallpaperInfoWithOnlineWallpaperVariants) {\n  SimulateUserLogin(account_id_1);\n\n  // auto run_loop = std::make_unique<base::RunLoop>();\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n\n  pref_manager_->SetUserWallpaperInfo(account_id_1, WallpaperInfo(params));\n  WallpaperInfo expected = WallpaperInfo(params);\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  EXPECT_EQ(expected, actual);\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaperIfExists) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER_CROPPED;\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_UNKNOWN);\n  SimulateUserLogin(account_id_1);\n\n  // Verify that calling |SetOnlineWallpaperIfExists| without providing image\n  // data fails.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId, variants);\n  controller_->SetOnlineWallpaperIfExists(\n      params, base::BindLambdaForTesting([&run_loop](bool file_exists) {\n        EXPECT_FALSE(file_exists);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Set an online wallpaper with image data. Verify that the wallpaper is set\n  // successfully.\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  // Verify that the user wallpaper info is updated.\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info = WallpaperInfo(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Change the on-screen wallpaper to a different one. (Otherwise the\n  // subsequent calls will be no-op since we intentionally prevent reloading the\n  // same wallpaper.)\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  CreateImage(640, 480, kWallpaperColor),\n                                  /*preview_mode=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n\n  // Attempt to set an online wallpaper via |SetOnlineWallpaperIfExists| without\n  // providing the image data. Verify it succeeds this time because\n  // |SetOnlineWallpaperFromData| has saved the file.\n  ClearWallpaperCount();\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->SetOnlineWallpaperIfExists(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            layout,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants),\n      base::BindLambdaForTesting([&run_loop](bool file_exists) {\n        EXPECT_TRUE(file_exists);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedForDarkLightWallpapers_NotSynced) {\n  SimulateUserLogin(account_id_1);\n  CacheOnlineWallpaper(kDummyUrl);\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // Force local info to not have a unit_id.\n  WallpaperInfo local_info = WallpaperInfo(params);\n  local_info.unit_id = absl::nullopt;\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  const OnlineWallpaperParams& params2 =\n      OnlineWallpaperParams(account_id_1, kAssetId2, GURL(kDummyUrl2),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // synced info tracks dark variant.\n  const WallpaperInfo& synced_info = WallpaperInfo(params2);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(synced_info, actual_info);\n  // Verify the wallpaper is set.\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedForDarkLightWallpapers_AlreadySynced) {\n  SimulateUserLogin(account_id_1);\n  CacheOnlineWallpaper(kDummyUrl);\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // local info tracks light variant.\n  const WallpaperInfo& local_info = WallpaperInfo(params);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  const OnlineWallpaperParams& params2 =\n      OnlineWallpaperParams(account_id_1, kAssetId2, GURL(kDummyUrl2),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // synced info tracks dark variant.\n  const WallpaperInfo& synced_info = WallpaperInfo(params2);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(local_info, synced_info);\n  EXPECT_EQ(local_info, actual_info);\n  // Verify the wallpaper is not set again.\n  EXPECT_EQ(0, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperCustomization_Used) {\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  // Emulate login screen behavior.\n  controller_->ShowSigninWallpaper();\n  // Let the task queue run so that we run `ShowWallpaperImage()`.\n  task_environment()->RunUntilIdle();\n\n  std::pair<const base::FilePath, const base::FilePath> paths =\n      CreateCustomizationWallpapers();\n  ASSERT_FALSE(paths.first.empty());\n  ASSERT_FALSE(paths.second.empty());\n\n  SetBypassDecode();\n  controller_->SetCustomizedDefaultWallpaperPaths(paths.first, paths.second);\n  task_environment()->RunUntilIdle();\n\n  // Verify that the customized wallpaper is in use.\n  EXPECT_THAT(GetCurrentWallpaperInfo().location,\n              testing::EndsWith(kCustomizationSmallWallpaperName));\n}\n\nTEST_F(WallpaperControllerTest, WallpaperCustomization_UnusedForNonDefault) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // Set wallpaper to something a user may have chose.\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  // Let the task queue run so that we run `ShowWallpaperImage()`.\n  task_environment()->RunUntilIdle();\n\n  // Simulate wallpaper customization retrieval completing after login.\n  std::pair<const base::FilePath, const base::FilePath> paths =\n      CreateCustomizationWallpapers();\n  ASSERT_FALSE(paths.first.empty());\n  ASSERT_FALSE(paths.second.empty());\n\n  controller_->SetCustomizedDefaultWallpaperPaths(paths.first, paths.second);\n  task_environment()->RunUntilIdle();\n\n  // Verify that we still use the online wallpaper. i.e. did not switch to\n  // default.\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nclass WallpaperControllerGooglePhotosWallpaperTest\n    : public WallpaperControllerTest,\n      public testing::WithParamInterface<bool> {\n public:\n  WallpaperControllerGooglePhotosWallpaperTest() {\n    if (GooglePhotosEnabled()) {\n      scoped_feature_list_.InitWithFeatures(\n          {ash::features::kWallpaperGooglePhotosIntegration}, {});\n    } else {\n      scoped_feature_list_.InitWithFeatures(\n          {}, {ash::features::kWallpaperGooglePhotosIntegration});\n    }\n  }\n\n  WallpaperControllerGooglePhotosWallpaperTest(\n      const WallpaperControllerGooglePhotosWallpaperTest&) = delete;\n  WallpaperControllerGooglePhotosWallpaperTest& operator=(\n      const WallpaperControllerGooglePhotosWallpaperTest&) = delete;\n\n  ~WallpaperControllerGooglePhotosWallpaperTest() override = default;\n\n  bool GooglePhotosEnabled() const { return GetParam(); }\n\n  void WaitForWallpaperCount(int count) {\n    base::RunLoop run_loop;\n    base::RepeatingTimer repeating_timer;\n    repeating_timer.Start(FROM_HERE, base::Milliseconds(10),\n                          base::BindLambdaForTesting([&]() {\n                            if (GetWallpaperCount() >= count) {\n                              repeating_timer.Stop();\n                              run_loop.Quit();\n                            }\n                          }));\n    run_loop.Run();\n  }\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\nINSTANTIATE_TEST_SUITE_P(All,\n                         WallpaperControllerGooglePhotosWallpaperTest,\n                         testing::Bool());\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, SetGooglePhotosWallpaper) {\n  bool feature_enabled = GooglePhotosEnabled();\n  SimulateUserLogin(account_id_1);\n\n  // First set the wallpaper to an Online one so we can tell for sure if setting\n  // a Google Photos wallpaper has failed.\n  base::test::TestFuture<bool> online_future;\n  controller_->SetOnlineWallpaper(\n      {account_id_1,\n       kAssetId,\n       GURL(kDummyUrl),\n       TestWallpaperControllerClient::kDummyCollectionId,\n       WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false,\n       /*from_user=*/true,\n       /*daily_refresh_enabled=*/false,\n       kUnitId,\n       {}},\n      online_future.GetCallback());\n  ASSERT_TRUE(online_future.Wait());\n  ASSERT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  // Now attempt setting a Google Photos wallpaper.\n  ClearWallpaperCount();\n  int expected_wallpaper_count = 0;\n  ASSERT_EQ(expected_wallpaper_count, GetWallpaperCount());\n  GooglePhotosWallpaperParams params(account_id_1, kFakeGooglePhotosPhotoId,\n                                     /*daily_refresh_enabled=*/false,\n                                     WallpaperLayout::WALLPAPER_LAYOUT_STRETCH,\n                                     /*preview_mode=*/false, \"dedup_key\");\n\n  controller_->SetGooglePhotosWallpaper(params, base::DoNothing());\n  if (feature_enabled)\n    ++expected_wallpaper_count;\n\n  WaitForWallpaperCount(expected_wallpaper_count);\n\n  EXPECT_EQ(feature_enabled, controller_->GetWallpaperType() ==\n                                 WallpaperType::kOnceGooglePhotos);\n\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(feature_enabled, wallpaper_info == expected_wallpaper_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       SetGooglePhotosWallpaperFails) {\n  SimulateUserLogin(account_id_1);\n\n  // First set the wallpaper to an Online one so we can tell for sure if setting\n  // a Google Photos wallpaper has failed.\n  base::test::TestFuture<bool> online_future;\n  OnlineWallpaperParams online_params(\n      {account_id_1,\n       kAssetId,\n       GURL(kDummyUrl),\n       TestWallpaperControllerClient::kDummyCollectionId,\n       WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false,\n       /*from_user=*/true,\n       /*daily_refresh_enabled=*/false,\n       kUnitId,\n       {}});\n  controller_->SetOnlineWallpaper(online_params, online_future.GetCallback());\n  ASSERT_TRUE(online_future.Wait());\n  ASSERT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  // Attempt to set a Google Photos wallpaper with the client set to fail to\n  // fetch the Google Photos photo data.\n  client_.set_fetch_google_photos_photo_fails(true);\n  ClearWallpaperCount();\n  ASSERT_EQ(0, GetWallpaperCount());\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, false,\n       WallpaperLayout::WALLPAPER_LAYOUT_STRETCH, false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_FALSE(google_photos_future.Get());\n  EXPECT_NE(controller_->GetWallpaperType(), WallpaperType::kOnceGooglePhotos);\n\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(online_params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       RetryTimerTriggersOnFailedFetchPhotoForStalenessCheck) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(account_id_1, kFakeGooglePhotosPhotoId,\n                                     /*daily_refresh_enabled=*/false,\n                                     WallpaperLayout::WALLPAPER_LAYOUT_STRETCH,\n                                     /*preview_mode=*/false,\n                                     /*dedup_key=*/absl::nullopt);\n  controller_->SetGooglePhotosWallpaper(params, base::DoNothing());\n  task_environment()->RunUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  // If the feature is disabled, setting a GooglePhotos wallpaper is a nop.\n  if (GooglePhotosEnabled()) {\n    base::TimeDelta one_day = base::Days(1);\n    // Leave a little wiggle room, as well as account for the hour fuzzing that\n    // we do.\n    EXPECT_GE(delay, one_day - base::Minutes(1));\n    EXPECT_LE(delay, one_day + base::Minutes(61));\n  } else {\n    EXPECT_FALSE(controller_->GetUpdateWallpaperTimerForTesting().IsRunning());\n  }\n\n  client_.set_fetch_google_photos_photo_fails(true);\n\n  // Trigger Google Photos wallpaper cache check.\n  controller_->OnActiveUserSessionChanged(account_id_1);\n\n  run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n\n  // The cache check does not happen when the feature is disabled, since the\n  // local `WallpaperInfo` is rejected.\n  if (GooglePhotosEnabled()) {\n    // Leave a little wiggle room.\n    EXPECT_GE(delay, one_hour - base::Minutes(1));\n    EXPECT_LE(delay, one_hour + base::Minutes(1));\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultForDeletedPhotoOnStalenessCheck) {\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {kFakeGooglePhotosPhotoId, WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kOnceGooglePhotos,\n                        DayBeforeYesterdayish()};\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  client_.set_google_photo_has_been_deleted(true);\n  // Trigger Google Photos wallpaper cache check.\n  controller_->OnActiveUserSessionChanged(account_id_1);\n  if (GooglePhotosEnabled())\n    WaitForWallpaperCount(1);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            controller_->GetWallpaperType() == WallpaperType::kDefault);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreCachedOnDisk) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH,\n       /*preview_mode=*/false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  base::FilePath saved_wallpaper = online_wallpaper_dir_.GetPath()\n                                       .Append(\"google_photos/\")\n                                       .Append(account_id_1.GetAccountIdKey())\n                                       .Append(kFakeGooglePhotosPhotoId);\n  ASSERT_EQ(GooglePhotosEnabled(), base::PathExists(saved_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreCachedInMemory) {\n  SimulateUserLogin(account_id_1);\n\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH,\n       /*preview_mode=*/false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  // We store an empty path for Google Photos wallpapers in the in-memory cache\n  // because storing the real path correctly would require updating the cache\n  // after the asynchronous save operation, and we have no use for it anyway.\n  EXPECT_EQ(GooglePhotosEnabled(),\n            controller_->GetPathFromCache(account_id_1, &path));\n  EXPECT_TRUE(path.empty());\n  EXPECT_EQ(GooglePhotosEnabled(), controller_->GetWallpaperFromCache(\n                                       account_id_1, &cached_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreReadFromCache) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n\n  GooglePhotosWallpaperParams params({account_id_1, kFakeGooglePhotosPhotoId,\n                                      /*daily_refresh_enabled=*/false,\n                                      WALLPAPER_LAYOUT_STRETCH,\n                                      /*preview_mode=*/false, \"dedup_key\"});\n  controller_->SetGooglePhotosWallpaper(params,\n                                        google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  // When Google Photos is disabled, the wallpaper will not be in disk cache,\n  // so it will attempt to read from disk, fail to find it, and then reset to\n  // the default wallpaper.\n  const size_t expected_decodes = GooglePhotosEnabled() ? 0 : 1;\n  const WallpaperType expected_type = GooglePhotosEnabled()\n                                          ? WallpaperType::kOnceGooglePhotos\n                                          : WallpaperType::kDefault;\n\n  EXPECT_EQ(expected_decodes, GetDecodeFilePaths().size());\n  EXPECT_EQ(expected_type, controller_->GetWallpaperType());\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, ConfirmPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false, layout,\n       /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  if (GooglePhotosEnabled()) {\n    // Now confirm the preview wallpaper, verify that there's no wallpaper\n    // change because the wallpaper is already shown.\n    ClearWallpaperCount();\n    controller_->ConfirmPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 0);\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n\n    // Verify that the user wallpaper info is now updated to the Google Photos\n    // wallpaper info.\n    WallpaperInfo google_photos_wallpaper_info(\n        photo_id, layout, WallpaperType::kOnceGooglePhotos,\n        base::Time::Now().LocalMidnight());\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, google_photos_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, CancelPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH, /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  if (GooglePhotosEnabled()) {\n    // Now cancel the preview. Verify the wallpaper changes back to the default\n    // and the user wallpaper info remains unchanged.\n    ClearWallpaperCount();\n    controller_->CancelPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 1);\n    EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n    EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       WallpaperSyncedDuringPreview) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false, layout,\n       /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  // Now set a custom wallpaper for the user and disable preview (this happens\n  // if a custom wallpaper set on another device is being synced). Verify\n  // there's no wallpaper change since preview mode shouldn't be interrupted.\n  if (GooglePhotosEnabled()) {\n    gfx::ImageSkia synced_custom_wallpaper =\n        CreateImage(640, 480, kWallpaperColor);\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                    synced_custom_wallpaper,\n                                    /*preview_mode=*/false);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 0);\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n\n    // However, the user wallpaper info should already be updated to the new\n    // info.\n    WallpaperInfo synced_custom_wallpaper_info(\n        base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(),\n        layout, WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n    // Now cancel the preview. Verify the synced custom wallpaper is shown\n    // instead of the initial default wallpaper, and the user wallpaper info is\n    // still correct.\n    ClearWallpaperCount();\n    controller_->CancelPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 1);\n    EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       UpdateGooglePhotosDailyRefreshWallpaper) {\n  // The `TestWallpaperControllerClient` sends back the reversed\n  // `collection_id` when asked to fetch a daily photo.\n  std::string expected_photo_id = kFakeGooglePhotosAlbumId;\n  std::reverse(expected_photo_id.begin(), expected_photo_id.end());\n\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo expected_info;\n  bool success =\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &expected_info);\n  EXPECT_EQ(success, GooglePhotosEnabled());\n  if (success) {\n    EXPECT_EQ(expected_photo_id, expected_info.location);\n    EXPECT_EQ(kFakeGooglePhotosAlbumId, expected_info.collection_id);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyRefreshTimerStartsForDailyGooglePhotos) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n  auto& timer = controller_->GetUpdateWallpaperTimerForTesting();\n  base::TimeDelta run_time =\n      timer.desired_run_time().ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      (base::Time::Now() + base::Days(1)).ToDeltaSinceWindowsEpoch();\n\n  if (GooglePhotosEnabled()) {\n    EXPECT_GE(run_time, update_time - base::Minutes(1));\n    EXPECT_LE(run_time, update_time + base::Minutes(61));\n  } else {\n    EXPECT_FALSE(timer.IsRunning());\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyRefreshRetryTimerStartsOnFailedFetch) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  client_.set_fetch_google_photos_photo_fails(true);\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  base::TimeDelta run_time = controller_->GetUpdateWallpaperTimerForTesting()\n                                 .desired_run_time()\n                                 .ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      (base::Time::Now() + base::Hours(1)).ToDeltaSinceWindowsEpoch();\n\n  if (GooglePhotosEnabled()) {\n    EXPECT_GE(run_time, update_time - base::Minutes(1));\n    EXPECT_LE(run_time, update_time + base::Minutes(1));\n  } else {\n    EXPECT_FALSE(controller_->GetUpdateWallpaperTimerForTesting().IsRunning());\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       EmptyDailyGooglePhotosAlbumsDoNothing) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams daily_google_photos_params(\n      account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*dedup_key=*/absl::nullopt);\n  OnlineWallpaperParams online_params(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n\n  WallpaperInfo online_info(online_params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, online_info);\n\n  client_.set_fetch_google_photos_photo_fails(true);\n  controller_->SetGooglePhotosWallpaper(daily_google_photos_params,\n                                        base::DoNothing());\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo current_info;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(online_info, current_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultForDeletedDailyGooglePhotosAlbums) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n       WallpaperLayout::WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false, /*dedup_key=*/absl::nullopt},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo current_info;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            WallpaperType::kDailyGooglePhotos == current_info.type);\n\n  // This makes the test fetch in `client_` return a null photo, but a\n  // successful call, which is the sign for a deleted or empty album.\n  client_.set_google_photo_has_been_deleted(true);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            WallpaperType::kDefault == current_info.type);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyGooglePhotosAreCached) {\n  SimulateUserLogin(account_id_1);\n  // The `TestWallpaperControllerClient` sends back the reversed\n  // `collection_id` when asked to fetch a daily photo.\n  std::string expected_photo_id = kFakeGooglePhotosAlbumId;\n  std::reverse(expected_photo_id.begin(), expected_photo_id.end());\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n       WallpaperLayout::WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false, /*dedup_key=*/absl::nullopt},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  base::FilePath saved_wallpaper = online_wallpaper_dir_.GetPath()\n                                       .Append(\"google_photos/\")\n                                       .Append(account_id_1.GetAccountIdKey())\n                                       .Append(expected_photo_id);\n  ASSERT_EQ(GooglePhotosEnabled(), base::PathExists(saved_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultWhenLoadingInvalidWallpaper) {\n  SimulateUserLogin(account_id_1);\n\n  const WallpaperType type = GooglePhotosEnabled()\n                                 ? WallpaperType::kCount\n                                 : WallpaperType::kOnceGooglePhotos;\n\n  WallpaperInfo info = {kFakeGooglePhotosPhotoId, WALLPAPER_LAYOUT_CENTER, type,\n                        base::Time::Now()};\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n}\n\n}  // namespace ash\n"
  },
  "written_data": {
    "ash/wallpaper/wallpaper_controller_unittest.cc": "// Copyright 2012 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ash/wallpaper/wallpaper_controller_impl.h\"\n\n#include <cmath>\n#include <cstdlib>\n#include <memory>\n#include <vector>\n\n#include \"ash/constants/ash_features.h\"\n#include \"ash/constants/ash_pref_names.h\"\n#include \"ash/constants/ash_switches.h\"\n#include \"ash/public/cpp/shell_window_ids.h\"\n#include \"ash/public/cpp/test/shell_test_api.h\"\n#include \"ash/public/cpp/test/test_image_downloader.h\"\n#include \"ash/public/cpp/wallpaper/online_wallpaper_params.h\"\n#include \"ash/public/cpp/wallpaper/online_wallpaper_variant.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_controller_client.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_controller_observer.h\"\n#include \"ash/public/cpp/wallpaper/wallpaper_types.h\"\n#include \"ash/root_window_controller.h\"\n#include \"ash/session/session_controller_impl.h\"\n#include \"ash/session/test_session_controller_client.h\"\n#include \"ash/shell.h\"\n#include \"ash/style/dark_light_mode_controller_impl.h\"\n#include \"ash/test/ash_test_base.h\"\n#include \"ash/wallpaper/test_wallpaper_controller_client.h\"\n#include \"ash/wallpaper/wallpaper_pref_manager.h\"\n#include \"ash/wallpaper/wallpaper_utils/wallpaper_resizer.h\"\n#include \"ash/wallpaper/wallpaper_view.h\"\n#include \"ash/wallpaper/wallpaper_widget_controller.h\"\n#include \"ash/webui/personalization_app/proto/backdrop_wallpaper.pb.h\"\n#include \"ash/wm/overview/overview_controller.h\"\n#include \"ash/wm/window_cycle/window_cycle_controller.h\"\n#include \"ash/wm/window_state.h\"\n#include \"base/callback_helpers.h\"\n#include \"base/command_line.h\"\n#include \"base/files/file_util.h\"\n#include \"base/files/scoped_temp_dir.h\"\n#include \"base/metrics/metrics_hashes.h\"\n#include \"base/run_loop.h\"\n#include \"base/strings/stringprintf.h\"\n#include \"base/task/current_thread.h\"\n#include \"base/task/task_observer.h\"\n#include \"base/task/thread_pool/thread_pool_instance.h\"\n#include \"base/test/bind.h\"\n#include \"base/test/metrics/histogram_tester.h\"\n#include \"base/test/scoped_feature_list.h\"\n#include \"base/test/task_environment.h\"\n#include \"base/test/test_future.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/time/time_override.h\"\n#include \"chromeos/constants/chromeos_features.h\"\n#include \"components/prefs/scoped_user_pref_update.h\"\n#include \"components/user_manager/user_names.h\"\n#include \"components/user_manager/user_type.h\"\n#include \"services/data_decoder/public/cpp/test_support/in_process_data_decoder.h\"\n#include \"testing/gmock/include/gmock/gmock-matchers.h\"\n#include \"third_party/skia/include/core/SkBitmap.h\"\n#include \"third_party/skia/include/core/SkColor.h\"\n#include \"ui/aura/window.h\"\n#include \"ui/compositor/layer.h\"\n#include \"ui/compositor/layer_tree_owner.h\"\n#include \"ui/compositor/scoped_animation_duration_scale_mode.h\"\n#include \"ui/compositor/test/layer_animator_test_controller.h\"\n#include \"ui/display/display.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/gfx/canvas.h\"\n#include \"ui/gfx/codec/jpeg_codec.h\"\n#include \"ui/gfx/color_analysis.h\"\n#include \"ui/views/view_tracker.h\"\n#include \"ui/views/widget/widget.h\"\n\nusing session_manager::SessionState;\n\nnamespace ash {\nnamespace {\n\n// Containers IDs used for tests.\nconstexpr int kWallpaperId = kShellWindowId_WallpaperContainer;\nconstexpr int kLockScreenWallpaperId =\n    kShellWindowId_LockScreenWallpaperContainer;\nconstexpr int kAlwaysOnTopWallpaperId =\n    kShellWindowId_AlwaysOnTopWallpaperContainer;\n\nconstexpr char kDefaultSmallWallpaperName[] = \"small.jpg\";\nconstexpr char kDefaultLargeWallpaperName[] = \"large.jpg\";\nconstexpr char kGuestSmallWallpaperName[] = \"guest_small.jpg\";\nconstexpr char kGuestLargeWallpaperName[] = \"guest_large.jpg\";\nconstexpr char kChildSmallWallpaperName[] = \"child_small.jpg\";\nconstexpr char kChildLargeWallpaperName[] = \"child_large.jpg\";\n\nconstexpr char kCustomizationSmallWallpaperName[] = \"small_customization.jpeg\";\nconstexpr char kCustomizationLargeWallpaperName[] = \"large_customization.jpeg\";\n\n// Colors used to distinguish between wallpapers with large and small\n// resolution.\nconstexpr SkColor kLargeCustomWallpaperColor = SK_ColorDKGRAY;\nconstexpr SkColor kSmallCustomWallpaperColor = SK_ColorLTGRAY;\n\n// A color that can be passed to |CreateImage|. Specifically chosen to not\n// conflict with any of the custom wallpaper colors.\nconstexpr SkColor kWallpaperColor = SK_ColorMAGENTA;\n\nstd::string GetDummyFileId(const AccountId& account_id) {\n  return account_id.GetUserEmail() + \"-hash\";\n}\n\nstd::string GetDummyFileName(const AccountId& account_id) {\n  return account_id.GetUserEmail() + \"-file\";\n}\n\nconstexpr char kUser1[] = \"user1@test.com\";\nconst AccountId account_id_1 = AccountId::FromUserEmailGaiaId(kUser1, kUser1);\nconst std::string wallpaper_files_id_1 = GetDummyFileId(account_id_1);\nconst std::string file_name_1 = GetDummyFileName(account_id_1);\n\nconstexpr char kUser2[] = \"user2@test.com\";\nconst AccountId account_id_2 = AccountId::FromUserEmailGaiaId(kUser2, kUser2);\nconst std::string wallpaper_files_id_2 = GetDummyFileId(account_id_2);\nconst std::string file_name_2 = GetDummyFileName(account_id_2);\n\nconstexpr char kChildEmail[] = \"child@test.com\";\n\nconst std::string kDummyUrl = \"https://best_wallpaper/1\";\nconst std::string kDummyUrl2 = \"https://best_wallpaper/2\";\n\nconst uint64_t kAssetId = 1;\nconst uint64_t kAssetId2 = 2;\nconst uint64_t kUnitId = 1;\nconst uint64_t kUnitId2 = 2;\n\nconst std::string kFakeGooglePhotosAlbumId = \"fake_album\";\nconst std::string kFakeGooglePhotosPhotoId = \"fake_photo\";\n\n// Creates an image of size |size|.\ngfx::ImageSkia CreateImage(int width, int height, SkColor color) {\n  SkBitmap bitmap;\n  bitmap.allocN32Pixels(width, height);\n  bitmap.eraseColor(color);\n  gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(bitmap);\n  return image;\n}\n\n// Returns number of child windows in a shell window container.\nint ChildCountForContainer(int container_id) {\n  aura::Window* root = Shell::Get()->GetPrimaryRootWindow();\n  aura::Window* container = root->GetChildById(container_id);\n  return static_cast<int>(container->children().size());\n}\n\n// Steps a layer animation until it is completed. Animations must be enabled.\nvoid RunAnimationForLayer(ui::Layer* layer) {\n  // Animations must be enabled for stepping to work.\n  ASSERT_NE(ui::ScopedAnimationDurationScaleMode::duration_multiplier(),\n            ui::ScopedAnimationDurationScaleMode::ZERO_DURATION);\n\n  ui::LayerAnimatorTestController controller(layer->GetAnimator());\n  // Multiple steps are required to complete complex animations.\n  // TODO(vollick): This should not be necessary. crbug.com/154017\n  while (controller.animator()->is_animating()) {\n    controller.StartThreadedAnimationsIfNeeded();\n    base::TimeTicks step_time = controller.animator()->last_step_time();\n    layer->GetAnimator()->Step(step_time + base::Milliseconds(1000));\n  }\n}\n\n// Writes a JPEG image of the specified size and color to |path|. Returns true\n// on success.\nbool WriteJPEGFile(const base::FilePath& path,\n                   int width,\n                   int height,\n                   SkColor color) {\n  base::ScopedAllowBlockingForTesting allow_blocking;\n  SkBitmap bitmap;\n  bitmap.allocN32Pixels(width, height);\n  bitmap.eraseColor(color);\n  std::vector<unsigned char> output;\n  if (!gfx::JPEGCodec::Encode(bitmap, 80 /*quality*/, &output)) {\n    LOG(ERROR) << \"Unable to encode \" << width << \"x\" << height << \" bitmap\";\n    return false;\n  }\n\n  size_t bytes_written = base::WriteFile(\n      path, reinterpret_cast<const char*>(&output[0]), output.size());\n  if (bytes_written != output.size()) {\n    LOG(ERROR) << \"Wrote \" << bytes_written << \" byte(s) instead of \"\n               << output.size() << \" to \" << path.value();\n    return false;\n  }\n  return true;\n}\n\n// Returns custom wallpaper path. Creates the directory if it doesn't exist.\nbase::FilePath GetCustomWallpaperPath(const char* sub_dir,\n                                      const std::string& wallpaper_files_id,\n                                      const std::string& file_name) {\n  base::ScopedAllowBlockingForTesting allow_blocking;\n  base::FilePath wallpaper_path =\n      WallpaperControllerImpl::GetCustomWallpaperPath(\n          sub_dir, wallpaper_files_id, file_name);\n  if (!base::DirectoryExists(wallpaper_path.DirName()))\n    base::CreateDirectory(wallpaper_path.DirName());\n\n  return wallpaper_path;\n}\n\nvoid WaitUntilCustomWallpapersDeleted(const AccountId& account_id) {\n  const std::string wallpaper_file_id = GetDummyFileId(account_id);\n\n  base::FilePath small_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kSmallWallpaperSubDir)\n          .Append(wallpaper_file_id);\n  base::FilePath large_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kLargeWallpaperSubDir)\n          .Append(wallpaper_file_id);\n  base::FilePath original_wallpaper_dir =\n      WallpaperControllerImpl::GetCustomWallpaperDir(\n          WallpaperControllerImpl::kOriginalWallpaperSubDir)\n          .Append(wallpaper_file_id);\n\n  while (base::PathExists(small_wallpaper_dir) ||\n         base::PathExists(large_wallpaper_dir) ||\n         base::PathExists(original_wallpaper_dir)) {\n  }\n}\n\n// Monitors if any task is processed by the message loop.\nclass TaskObserver : public base::TaskObserver {\n public:\n  TaskObserver() : processed_(false) {}\n\n  TaskObserver(const TaskObserver&) = delete;\n  TaskObserver& operator=(const TaskObserver&) = delete;\n\n  ~TaskObserver() override = default;\n\n  // TaskObserver:\n  void WillProcessTask(const base::PendingTask& /* pending_task */,\n                       bool /* was_blocked_or_low_priority */) override {}\n  void DidProcessTask(const base::PendingTask& pending_task) override {\n    processed_ = true;\n  }\n\n  // Returns true if any task was processed.\n  bool processed() const { return processed_; }\n\n private:\n  bool processed_;\n};\n\n// See content::RunAllTasksUntilIdle().\nvoid RunAllTasksUntilIdle() {\n  while (true) {\n    TaskObserver task_observer;\n    base::CurrentThread::Get()->AddTaskObserver(&task_observer);\n    // May spin message loop.\n    base::ThreadPoolInstance::Get()->FlushForTesting();\n\n    base::RunLoop().RunUntilIdle();\n    base::CurrentThread::Get()->RemoveTaskObserver(&task_observer);\n\n    if (!task_observer.processed())\n      break;\n  }\n}\n\nPrefService* GetProfilePrefService(const AccountId& account_id) {\n  return Shell::Get()->session_controller()->GetUserPrefServiceForUser(\n      account_id);\n}\n\nWallpaperInfo InfoWithType(WallpaperType type) {\n  WallpaperInfo info(std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, type,\n                     base::Time::Now());\n  if (type == WallpaperType::kDaily || type == WallpaperType::kOnline) {\n    // Daily and Online types require asset id and collection id.\n    info.asset_id = 1234;\n    info.collection_id = \"placeholder collection\";\n    info.location = \"https://example.com/example.jpeg\";\n  }\n  if (type == WallpaperType::kOnceGooglePhotos)\n    info.dedup_key = \"dedup_key\";\n  return info;\n}\n\nbase::Time DayBeforeYesterdayish() {\n  base::TimeDelta today_delta =\n      base::Time::Now().LocalMidnight().ToDeltaSinceWindowsEpoch();\n  base::TimeDelta yesterday_delta = today_delta - base::Days(2);\n  return base::Time::FromDeltaSinceWindowsEpoch(yesterday_delta);\n}\n\n// A test implementation of the WallpaperControllerObserver interface.\nclass TestWallpaperControllerObserver : public WallpaperControllerObserver {\n public:\n  explicit TestWallpaperControllerObserver(WallpaperController* controller)\n      : controller_(controller) {\n    controller_->AddObserver(this);\n  }\n\n  TestWallpaperControllerObserver(const TestWallpaperControllerObserver&) =\n      delete;\n  TestWallpaperControllerObserver& operator=(\n      const TestWallpaperControllerObserver&) = delete;\n\n  ~TestWallpaperControllerObserver() override {\n    controller_->RemoveObserver(this);\n  }\n\n  // WallpaperControllerObserver\n  void OnWallpaperChanged() override { ++wallpaper_changed_count_; }\n  void OnWallpaperColorsChanged() override { ++colors_changed_count_; }\n  void OnWallpaperBlurChanged() override { ++blur_changed_count_; }\n  void OnFirstWallpaperShown() override { ++first_shown_count_; }\n  void OnWallpaperPreviewStarted() override {\n    DCHECK(!is_in_wallpaper_preview_);\n    is_in_wallpaper_preview_ = true;\n  }\n  void OnWallpaperPreviewEnded() override {\n    DCHECK(is_in_wallpaper_preview_);\n    is_in_wallpaper_preview_ = false;\n  }\n\n  int colors_changed_count() const { return colors_changed_count_; }\n  int blur_changed_count() const { return blur_changed_count_; }\n  int first_shown_count() const { return first_shown_count_; }\n  int wallpaper_changed_count() const { return wallpaper_changed_count_; }\n  bool is_in_wallpaper_preview() const { return is_in_wallpaper_preview_; }\n\n private:\n  WallpaperController* controller_;\n  int colors_changed_count_ = 0;\n  int blur_changed_count_ = 0;\n  int first_shown_count_ = 0;\n  int wallpaper_changed_count_ = 0;\n  bool is_in_wallpaper_preview_ = false;\n};\n\n}  // namespace\n\nclass WallpaperControllerTest : public AshTestBase {\n public:\n  WallpaperControllerTest()\n      : AshTestBase(base::test::TaskEnvironment::TimeSource::MOCK_TIME) {}\n\n  WallpaperControllerTest(const WallpaperControllerTest&) = delete;\n  WallpaperControllerTest& operator=(const WallpaperControllerTest&) = delete;\n\n  void SetUp() override {\n    auto pref_manager = WallpaperPrefManager::Create(local_state());\n    pref_manager_ = pref_manager.get();\n    // Override the pref manager that will be used to construct the\n    // WallpaperController.\n    WallpaperControllerImpl::SetWallpaperPrefManagerForTesting(\n        std::move(pref_manager));\n\n    AshTestBase::SetUp();\n\n    TestSessionControllerClient* const client = GetSessionControllerClient();\n    client->ProvidePrefServiceForUser(account_id_1);\n    client->ProvidePrefServiceForUser(account_id_2);\n    client->ProvidePrefServiceForUser(\n        AccountId::FromUserEmail(user_manager::kGuestUserName));\n    client->ProvidePrefServiceForUser(kChildAccountId);\n\n    // This is almost certainly not what was originally intended for these\n    // tests, but they have never actually exercised properly decoded\n    // wallpapers, as they've never actually been connected to a Data Decoder.\n    // We simulate a \"crashing\" ImageDcoder to get the behavior the tests were\n    // written around, but at some point they should probably be fixed.\n    in_process_data_decoder_.service().SimulateImageDecoderCrashForTesting(\n        true);\n\n    test_image_downloader_ = std::make_unique<TestImageDownloader>();\n\n    controller_ = Shell::Get()->wallpaper_controller();\n    controller_->set_wallpaper_reload_no_delay_for_test();\n\n    ASSERT_TRUE(user_data_dir_.CreateUniqueTempDir());\n    ASSERT_TRUE(online_wallpaper_dir_.CreateUniqueTempDir());\n    ASSERT_TRUE(custom_wallpaper_dir_.CreateUniqueTempDir());\n    base::FilePath policy_wallpaper;\n    controller_->Init(user_data_dir_.GetPath(), online_wallpaper_dir_.GetPath(),\n                      custom_wallpaper_dir_.GetPath(), policy_wallpaper);\n    client_.ResetCounts();\n    controller_->SetClient(&client_);\n    client_.set_fake_files_id_for_account_id(account_id_1,\n                                             wallpaper_files_id_1);\n    client_.set_fake_files_id_for_account_id(account_id_2,\n                                             wallpaper_files_id_2);\n  }\n\n  void TearDown() override {\n    // Although pref services outlive wallpaper controller in the os, in ash\n    // tests, they are destroyed in tear down (See |AshTestHelper|). We don't\n    // want this timer to run a task after tear down, since it relies on a pref\n    // service being around.\n    controller_->GetUpdateWallpaperTimerForTesting().Stop();\n\n    AshTestBase::TearDown();\n  }\n\n  WallpaperView* wallpaper_view() {\n    return Shell::Get()\n        ->GetPrimaryRootWindowController()\n        ->wallpaper_widget_controller()\n        ->wallpaper_view();\n  }\n\n protected:\n  // Helper function that tests the wallpaper is always fitted to the native\n  // display resolution when the layout is WALLPAPER_LAYOUT_CENTER.\n  void WallpaperFitToNativeResolution(WallpaperView* view,\n                                      float device_scale_factor,\n                                      int image_width,\n                                      int image_height,\n                                      SkColor color) {\n    gfx::Size size = view->bounds().size();\n    gfx::Canvas canvas(size, device_scale_factor, true);\n    view->OnPaint(&canvas);\n\n    SkBitmap bitmap = canvas.GetBitmap();\n    int bitmap_width = bitmap.width();\n    int bitmap_height = bitmap.height();\n    for (int i = 0; i < bitmap_width; i++) {\n      for (int j = 0; j < bitmap_height; j++) {\n        if (i >= (bitmap_width - image_width) / 2 &&\n            i < (bitmap_width + image_width) / 2 &&\n            j >= (bitmap_height - image_height) / 2 &&\n            j < (bitmap_height + image_height) / 2) {\n          EXPECT_EQ(color, bitmap.getColor(i, j));\n        } else {\n          EXPECT_EQ(SK_ColorBLACK, bitmap.getColor(i, j));\n        }\n      }\n    }\n  }\n\n  // Runs AnimatingWallpaperWidgetController's animation to completion.\n  void RunDesktopControllerAnimation() {\n    WallpaperWidgetController* controller =\n        Shell::Get()\n            ->GetPrimaryRootWindowController()\n            ->wallpaper_widget_controller();\n    ASSERT_TRUE(controller);\n\n    ui::LayerTreeOwner* owner = controller->old_layer_tree_owner_for_testing();\n    if (!owner)\n      return;\n\n    ASSERT_NO_FATAL_FAILURE(RunAnimationForLayer(owner->root()));\n  }\n\n  // Convenience function to ensure ShouldCalculateColors() returns true.\n  void EnableShelfColoring() {\n    const gfx::ImageSkia kImage = CreateImage(10, 10, kWallpaperColor);\n    controller_->ShowWallpaperImage(\n        kImage, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    SetSessionState(SessionState::ACTIVE);\n\n    EXPECT_TRUE(ShouldCalculateColors());\n  }\n\n  // Convenience function to set the SessionState.\n  void SetSessionState(SessionState session_state) {\n    GetSessionControllerClient()->SetSessionState(session_state);\n  }\n\n  // Helper function to create a |WallpaperInfo| struct with dummy values\n  // given the desired layout.\n  WallpaperInfo CreateWallpaperInfo(WallpaperLayout layout) {\n    return WallpaperInfo(std::string(), layout, WallpaperType::kDefault,\n                         base::Time::Now().LocalMidnight());\n  }\n\n  // Saves wallpaper images in the appropriate location for |account_id| and\n  // returns the relative path of the file.\n  base::FilePath PrecacheWallpapers(const AccountId& account_id) {\n    std::string wallpaper_files_id = GetDummyFileId(account_id);\n\n    std::string file_name = GetDummyFileName(account_id);\n    base::FilePath small_wallpaper_path =\n        GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                               wallpaper_files_id, file_name);\n    base::FilePath large_wallpaper_path =\n        GetCustomWallpaperPath(WallpaperControllerImpl::kLargeWallpaperSubDir,\n                               wallpaper_files_id, file_name);\n\n    // Saves the small/large resolution wallpapers to small/large custom\n    // wallpaper paths.\n    CHECK(WriteJPEGFile(small_wallpaper_path, kSmallWallpaperMaxWidth,\n                        kSmallWallpaperMaxHeight, kSmallCustomWallpaperColor));\n    CHECK(WriteJPEGFile(large_wallpaper_path, kLargeWallpaperMaxWidth,\n                        kLargeWallpaperMaxHeight, kLargeCustomWallpaperColor));\n\n    return base::FilePath(wallpaper_files_id).Append(file_name);\n  }\n\n  // Saves images with different resolution to corresponding paths and saves\n  // wallpaper info to local state, so that subsequent calls of |ShowWallpaper|\n  // can retrieve the images and info.\n  void CreateAndSaveWallpapers(const AccountId& account_id) {\n    base::FilePath relative_path = PrecacheWallpapers(account_id);\n    // Saves wallpaper info to local state for user.\n    WallpaperInfo info = {\n        relative_path.value(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n        WallpaperType::kCustomized, base::Time::Now().LocalMidnight()};\n    ASSERT_TRUE(pref_manager_->SetUserWallpaperInfo(account_id, info));\n  }\n\n  // Simulates setting a custom wallpaper by directly setting the wallpaper\n  // info.\n  void SimulateSettingCustomWallpaper(const AccountId& account_id) {\n    ASSERT_TRUE(pref_manager_->SetUserWallpaperInfo(\n        account_id,\n        WallpaperInfo(\"dummy_file_location\", WALLPAPER_LAYOUT_CENTER,\n                      WallpaperType::kCustomized,\n                      base::Time::Now().LocalMidnight())));\n  }\n\n  // Initializes default wallpaper paths \"*default_*file\" and writes JPEG\n  // wallpaper images to them. Only needs to be called (once) by tests that\n  // want to test loading of default wallpapers.\n  void CreateDefaultWallpapers() {\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    ASSERT_TRUE(default_wallpaper_dir_.CreateUniqueTempDir());\n    const base::FilePath default_wallpaper_path =\n        default_wallpaper_dir_.GetPath();\n\n    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n    const base::FilePath small_file =\n        default_wallpaper_path.Append(kDefaultSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kDefaultWallpaperSmall,\n                                    small_file.value());\n    const base::FilePath large_file =\n        default_wallpaper_path.Append(kDefaultLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kDefaultWallpaperLarge,\n                                    large_file.value());\n\n    const base::FilePath guest_small_file =\n        default_wallpaper_path.Append(kGuestSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kGuestWallpaperSmall,\n                                    guest_small_file.value());\n    const base::FilePath guest_large_file =\n        default_wallpaper_path.Append(kGuestLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kGuestWallpaperLarge,\n                                    guest_large_file.value());\n\n    const base::FilePath child_small_file =\n        default_wallpaper_path.Append(kChildSmallWallpaperName);\n    command_line->AppendSwitchASCII(switches::kChildWallpaperSmall,\n                                    child_small_file.value());\n    const base::FilePath child_large_file =\n        default_wallpaper_path.Append(kChildLargeWallpaperName);\n    command_line->AppendSwitchASCII(switches::kChildWallpaperLarge,\n                                    child_large_file.value());\n\n    const int kWallpaperSize = 2;\n    ASSERT_TRUE(WriteJPEGFile(small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n\n    ASSERT_TRUE(WriteJPEGFile(guest_small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(guest_large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n\n    ASSERT_TRUE(WriteJPEGFile(child_small_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n    ASSERT_TRUE(WriteJPEGFile(child_large_file, kWallpaperSize, kWallpaperSize,\n                              kWallpaperColor));\n  }\n\n  // Returns the paths of a small and large jpeg for use with customized default\n  // wallpapers.\n  [[nodiscard]] std::pair<const base::FilePath, const base::FilePath>\n  CreateCustomizationWallpapers() {\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    CHECK(customization_wallpaper_dir_.CreateUniqueTempDir());\n\n    base::FilePath root = customization_wallpaper_dir_.GetPath();\n\n    const base::FilePath small_file =\n        root.Append(kCustomizationSmallWallpaperName);\n    const base::FilePath large_file =\n        root.Append(kCustomizationLargeWallpaperName);\n\n    CHECK(WriteJPEGFile(small_file, 800, 800, SK_ColorGREEN));\n    CHECK(WriteJPEGFile(large_file, 2000, 2000, SK_ColorBLUE));\n\n    return {small_file, large_file};\n  }\n\n  // A helper to test the behavior of setting online wallpaper after the image\n  // is decoded. This is needed because image decoding is not supported in unit\n  // tests.\n  void SetOnlineWallpaperFromImage(\n      const AccountId& account_id,\n      uint64_t asset_id,\n      const gfx::ImageSkia& image,\n      const std::string& url,\n      const std::string& collection_id,\n      WallpaperLayout layout,\n      bool save_file,\n      bool preview_mode,\n      bool from_user,\n      uint64_t unit_id,\n      const std::vector<OnlineWallpaperVariant>& variants,\n      WallpaperController::SetWallpaperCallback callback) {\n    const OnlineWallpaperParams params = {\n        account_id, asset_id,     GURL(url), collection_id,\n        layout,     preview_mode, from_user, /*daily_refresh_enabled=*/false,\n        unit_id,    variants};\n    controller_->OnOnlineWallpaperDecoded(params, save_file,\n                                          std::move(callback), image);\n  }\n\n  // Returns color of the current wallpaper. Note: this function assumes the\n  // wallpaper has a solid color.\n  SkColor GetWallpaperColor() {\n    const gfx::ImageSkiaRep& representation =\n        controller_->GetWallpaper().GetRepresentation(1.0f);\n    return representation.GetBitmap().getColor(0, 0);\n  }\n\n  // Wrapper for private ShouldCalculateColors().\n  bool ShouldCalculateColors() { return controller_->ShouldCalculateColors(); }\n\n  // Wrapper for private IsDevicePolicyWallpaper().\n  bool IsDevicePolicyWallpaper() {\n    return controller_->IsDevicePolicyWallpaper();\n  }\n\n  int GetWallpaperCount() { return controller_->wallpaper_count_for_testing_; }\n\n  const std::vector<base::FilePath>& GetDecodeFilePaths() {\n    return controller_->decode_requests_for_testing_;\n  }\n\n  // Returns the `WallpaperInfo` associated with the current\n  // `WallpaperResizer`. Usually, this is the same as\n  // `GetActiveUserWallpaperInfo()` except when the user is not logged in.\n  const WallpaperInfo GetCurrentWallpaperInfo() {\n    WallpaperResizer* wallpaper = controller_->current_wallpaper_.get();\n    if (!wallpaper)\n      return WallpaperInfo();\n\n    return wallpaper->wallpaper_info();\n  }\n\n  void SetBypassDecode() { controller_->set_bypass_decode_for_testing(); }\n\n  void ClearWallpaperCount() { controller_->wallpaper_count_for_testing_ = 0; }\n\n  void ClearDecodeFilePaths() {\n    controller_->decode_requests_for_testing_.clear();\n  }\n\n  void ClearWallpaper() { controller_->current_wallpaper_.reset(); }\n\n  int GetWallpaperContainerId() {\n    return controller_->GetWallpaperContainerId(controller_->locked_);\n  }\n\n  const base::HistogramTester& histogram_tester() const {\n    return histogram_tester_;\n  }\n\n  void CacheOnlineWallpaper(std::string path) {\n    // Set an Online Wallpaper from Data, so syncing in doesn't need to download\n    // an Online Wallpaper.\n    SetBypassDecode();\n    SimulateUserLogin(account_id_1);\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaperFromData(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(path),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        /*image_data=*/std::string(),\n        WallpaperController::SetWallpaperCallback());\n    RunAllTasksUntilIdle();\n\n    // Change the on-screen wallpaper to a different one. (Otherwise the\n    // subsequent calls will be no-op since we intentionally prevent reloading\n    // the same wallpaper.)\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(\n        account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER_CROPPED,\n        CreateImage(640, 480, kWallpaperColor), false /*preview_mode=*/);\n    RunAllTasksUntilIdle();\n  }\n\n  WallpaperControllerImpl* controller_;\n  WallpaperPrefManager* pref_manager_ = nullptr;  // owned by controller\n\n  base::ScopedTempDir user_data_dir_;\n  base::ScopedTempDir online_wallpaper_dir_;\n  base::ScopedTempDir custom_wallpaper_dir_;\n  base::ScopedTempDir default_wallpaper_dir_;\n  base::ScopedTempDir customization_wallpaper_dir_;\n  base::HistogramTester histogram_tester_;\n\n  TestWallpaperControllerClient client_;\n  std::unique_ptr<TestImageDownloader> test_image_downloader_;\n\n  const AccountId kChildAccountId =\n      AccountId::FromUserEmailGaiaId(kChildEmail, kChildEmail);\n\n private:\n  data_decoder::test::InProcessDataDecoder in_process_data_decoder_;\n};\n\nTEST_F(WallpaperControllerTest, Client) {\n  base::FilePath empty_path;\n  controller_->Init(empty_path, empty_path, empty_path, empty_path);\n\n  EXPECT_EQ(0u, client_.open_count());\n  EXPECT_TRUE(controller_->CanOpenWallpaperPicker());\n  controller_->OpenWallpaperPickerIfAllowed();\n  EXPECT_EQ(1u, client_.open_count());\n}\n\nTEST_F(WallpaperControllerTest, BasicReparenting) {\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Wallpaper view/window exists in the wallpaper container and nothing is in\n  // the lock screen wallpaper container.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n\n  controller->OnSessionStateChanged(session_manager::SessionState::LOCKED);\n\n  // One window is moved from desktop to lock container.\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kLockScreenWallpaperId));\n\n  controller->OnSessionStateChanged(session_manager::SessionState::ACTIVE);\n\n  // One window is moved from lock to desktop container.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n}\n\nTEST_F(WallpaperControllerTest, SwitchWallpapersWhenNewWallpaperAnimationEnds) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Create the wallpaper and its view.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // The new wallpaper is ready to animate.\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n\n  // Force the animation to play to completion.\n  RunDesktopControllerAnimation();\n  EXPECT_FALSE(widget_controller->IsAnimating());\n}\n\n// Test for crbug.com/149043 \"Unlock screen, no launcher appears\". Ensure we\n// move all wallpaper views if there are more than one.\nTEST_F(WallpaperControllerTest, WallpaperMovementDuringUnlock) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Reset wallpaper state, see ControllerOwnership above.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  // User locks the screen, which moves the wallpaper forward.\n  controller->OnSessionStateChanged(session_manager::SessionState::LOCKED);\n\n  // Suspend/resume cycle causes wallpaper to refresh, loading a new wallpaper\n  // that will animate in on top of the old one.\n  controller->CreateEmptyWallpaperForTesting();\n\n  // In this state we have a wallpaper views stored in\n  // LockScreenWallpaperContainer.\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kLockScreenWallpaperId));\n  // There must be three layers, shield, original and old layers.\n  ASSERT_EQ(3u, wallpaper_view()->layer()->parent()->children().size());\n\n  // Before the wallpaper's animation completes, user unlocks the screen, which\n  // moves the wallpaper to the back.\n  controller->OnSessionStateChanged(session_manager::SessionState::ACTIVE);\n\n  // Ensure that widget has moved.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  // There must be two layers, original and old layers while animating.\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n\n  // Finish the new wallpaper animation.\n  RunDesktopControllerAnimation();\n\n  // Now there is one wallpaper and layer.\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  ASSERT_EQ(1u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(0, ChildCountForContainer(kLockScreenWallpaperId));\n}\n\n// Test for crbug.com/156542. Animating wallpaper should immediately finish\n// animation and replace current wallpaper before next animation starts.\nTEST_F(WallpaperControllerTest, ChangeWallpaperQuick) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  // Reset wallpaper state, see ControllerOwnership above.\n  WallpaperControllerImpl* controller = Shell::Get()->wallpaper_controller();\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  // Change to a new wallpaper.\n  controller->CreateEmptyWallpaperForTesting();\n\n  WallpaperWidgetController* widget_controller =\n      Shell::Get()\n          ->GetPrimaryRootWindowController()\n          ->wallpaper_widget_controller();\n  EXPECT_TRUE(widget_controller->IsAnimating());\n\n  // Change to another wallpaper before animation finished.\n  controller->CreateEmptyWallpaperForTesting();\n\n  // Run wallpaper show animation to completion.\n  RunDesktopControllerAnimation();\n\n  EXPECT_FALSE(widget_controller->IsAnimating());\n}\n\nTEST_F(WallpaperControllerTest, ResizeCustomWallpaper) {\n  UpdateDisplay(\"320x200\");\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n\n  // Set the image as custom wallpaper, wait for the resize to finish, and check\n  // that the resized image is the expected size.\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  EXPECT_TRUE(image.BackedBySameObjectAs(controller_->GetWallpaper()));\n  RunAllTasksUntilIdle();\n  gfx::ImageSkia resized_image = controller_->GetWallpaper();\n  EXPECT_FALSE(image.BackedBySameObjectAs(resized_image));\n  EXPECT_EQ(gfx::Size(320, 200).ToString(), resized_image.size().ToString());\n\n  // Load the original wallpaper again and check that we're still using the\n  // previously-resized image instead of doing another resize\n  // (http://crbug.com/321402).\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(resized_image.BackedBySameObjectAs(controller_->GetWallpaper()));\n}\n\nTEST_F(WallpaperControllerTest, GetMaxDisplaySize) {\n  // Device scale factor shouldn't affect the native size.\n  UpdateDisplay(\"1000x300*2\");\n  EXPECT_EQ(\"1000x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Rotated display should return the rotated size.\n  UpdateDisplay(\"1000x300*2/r\");\n  EXPECT_EQ(\"300x1000\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // UI Scaling shouldn't affect the native size.\n  UpdateDisplay(\"1000x300*2@1.5\");\n  EXPECT_EQ(\"1000x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // First display has maximum size.\n  UpdateDisplay(\"400x300,200x100\");\n  EXPECT_EQ(\"400x300\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Second display has maximum size.\n  UpdateDisplay(\"400x300,500x600\");\n  EXPECT_EQ(\"500x600\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n\n  // Maximum width and height belongs to different displays.\n  UpdateDisplay(\"400x300,100x500\");\n  EXPECT_EQ(\"400x500\",\n            WallpaperControllerImpl::GetMaxDisplaySizeInNative().ToString());\n}\n\n// Test that the wallpaper is always fitted to the native display resolution\n// when the layout is WALLPAPER_LAYOUT_CENTER to prevent blurry images.\nTEST_F(WallpaperControllerTest, DontScaleWallpaperWithCenterLayout) {\n  // We cannot short-circuit animations for this test.\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  const gfx::Size high_resolution(3600, 2400);\n  const gfx::Size low_resolution(360, 240);\n  const float high_dsf = 2.0f;\n  const float low_dsf = 1.0f;\n\n  gfx::ImageSkia image_high_res = CreateImage(\n      high_resolution.width(), high_resolution.height(), kWallpaperColor);\n  gfx::ImageSkia image_low_res = CreateImage(\n      low_resolution.width(), low_resolution.height(), kWallpaperColor);\n\n  UpdateDisplay(\"1200x600*2\");\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600*2 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600*2 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), high_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n\n  UpdateDisplay(\"1200x600\");\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n\n  UpdateDisplay(\"1200x600/u@1.5\");  // 1.5 ui scale\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600/u@1.5 high resolution\"));\n    controller_->ShowWallpaperImage(\n        image_high_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   high_resolution.width(),\n                                   high_resolution.height(), kWallpaperColor);\n  }\n  {\n    SCOPED_TRACE(base::StringPrintf(\"1200x600/u@1.5 low resolution\"));\n    controller_->ShowWallpaperImage(\n        image_low_res, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n        /*preview_mode=*/false, /*always_on_top=*/false);\n    WallpaperFitToNativeResolution(wallpaper_view(), low_dsf,\n                                   low_resolution.width(),\n                                   low_resolution.height(), kWallpaperColor);\n  }\n}\n\nTEST_F(WallpaperControllerTest, ShouldCalculateColorsBasedOnImage) {\n  EnableShelfColoring();\n  EXPECT_TRUE(ShouldCalculateColors());\n\n  controller_->CreateEmptyWallpaperForTesting();\n  EXPECT_FALSE(ShouldCalculateColors());\n}\n\nTEST_F(WallpaperControllerTest, ShouldCalculateColorsBasedOnSessionState) {\n  EnableShelfColoring();\n\n  SetSessionState(SessionState::UNKNOWN);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::OOBE);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_TRUE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_FALSE(ShouldCalculateColors());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  EXPECT_FALSE(ShouldCalculateColors());\n}\n\nTEST_F(WallpaperControllerTest, EnableShelfColoringNotifiesObservers) {\n  TestWallpaperControllerObserver observer(controller_);\n  EXPECT_EQ(0, observer.colors_changed_count());\n\n  // Enable shelf coloring will set a customized wallpaper image and change\n  // session state to ACTIVE, which will trigger wallpaper colors calculation.\n  EnableShelfColoring();\n  base::RunLoop().RunUntilIdle();\n  EXPECT_EQ(1, observer.colors_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, ProminentColor_CachedColorsAvailableAtLogin) {\n  SetBypassDecode();\n  // Cache some wallpapers and store that in the local prefs. Otherwise, we\n  // can't cache colors.\n  base::FilePath relative_path = PrecacheWallpapers(account_id_1);\n  WallpaperInfo info = InfoWithType(WallpaperType::kCustomized);\n  info.location = relative_path.value();\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_1, info));\n\n  // Store colors in local prefs simulating cache behavior.\n  const std::vector<SkColor> prominent_colors = {SK_ColorGREEN, SK_ColorRED,\n                                                 SK_ColorBLUE,  SK_ColorWHITE,\n                                                 SK_ColorWHITE, SK_ColorWHITE};\n  pref_manager_->CacheProminentColors(account_id_1, prominent_colors);\n  const SkColor k_means_color = SK_ColorLTGRAY;\n  pref_manager_->CacheKMeanColor(account_id_1, k_means_color);\n\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  TestWallpaperControllerObserver observer(controller_);\n  ASSERT_EQ(0, observer.colors_changed_count());\n\n  // Show user wallpaper in login screen. We are *not* logged in yet.\n  controller_->ShowUserWallpaper(account_id_1,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n\n  // Showing a user wallpaper should cause the cached colors to be fetched and\n  // reported.\n  EXPECT_EQ(1, observer.colors_changed_count());\n\n  // DARK_VIBRANT happens to be prominent color 0.\n  EXPECT_EQ(SK_ColorGREEN, controller_->GetProminentColor(\n                               {color_utils::LumaRange::DARK,\n                                color_utils::SaturationRange::VIBRANT}));\n  EXPECT_EQ(k_means_color, controller_->GetKMeanColor());\n}\n\nTEST_F(WallpaperControllerTest, ProminentColor_ClearedBetweenUsers) {\n  SetBypassDecode();\n  // Setup prominent colors for account 1.\n  base::FilePath relative_path = PrecacheWallpapers(account_id_1);\n  WallpaperInfo info = InfoWithType(WallpaperType::kCustomized);\n  info.location = relative_path.value();\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_1, info));\n\n  const std::vector<SkColor> prominent_colors = {SK_ColorGREEN, SK_ColorRED,\n                                                 SK_ColorBLUE,  SK_ColorWHITE,\n                                                 SK_ColorWHITE, SK_ColorWHITE};\n  pref_manager_->CacheProminentColors(account_id_1, prominent_colors);\n  const SkColor k_means_color = SK_ColorLTGRAY;\n  pref_manager_->CacheKMeanColor(account_id_1, k_means_color);\n\n  // Set a wallpaper for account 2.\n  WallpaperInfo info2 = InfoWithType(WallpaperType::kDefault);\n  ASSERT_TRUE(pref_manager_->SetLocalWallpaperInfo(account_id_2, info2));\n\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Show wallpaper for account 1.\n  controller_->ShowUserWallpaper(account_id_1,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n\n  // Verify that we can retrieve the prominent color.\n  EXPECT_EQ(SK_ColorGREEN, controller_->GetProminentColor(\n                               {color_utils::LumaRange::DARK,\n                                color_utils::SaturationRange::VIBRANT}));\n\n  // Show wallpaper for account 2.\n  controller_->ShowUserWallpaper(account_id_2,\n                                 user_manager::UserType::USER_TYPE_REGULAR);\n  task_environment()->RunUntilIdle();\n  // Since account 2 has not cached colors, the prominent color should be\n  // invalid.\n  EXPECT_EQ(\n      kInvalidWallpaperColor,\n      controller_->GetProminentColor({color_utils::LumaRange::DARK,\n                                      color_utils::SaturationRange::VIBRANT}));\n  EXPECT_EQ(2, observer.colors_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaperFromDataSavesFile) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // Verify that there's no offline wallpaper available in the beginning.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_TRUE(url_list.empty());\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n\n  // Set an online wallpaper with image data.\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n\n  // Verify that the wallpaper with |url| is available offline, and the returned\n  // file name should not contain the small wallpaper suffix.\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_EQ(1U, url_list.size());\n        EXPECT_EQ(GURL(kDummyUrl).ExtractFileName(), url_list[0]);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdatePrimaryUserWallpaperWhileSecondUserActive) {\n  SetBypassDecode();\n  WallpaperInfo wallpaper_info;\n\n  SimulateUserLogin(account_id_1);\n\n  // Set an online wallpaper with image data. Verify that the wallpaper is set\n  // successfully.\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  // Verify that the user wallpaper info is updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Log in |kUser2|, and set another online wallpaper for |kUser1|. Verify that\n  // the on-screen wallpaper doesn't change since |kUser1| is not active, but\n  // wallpaper info is updated properly.\n  SimulateUserLogin(account_id_2);\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& new_params = OnlineWallpaperParams(\n      account_id_1, kAssetId2, GURL(kDummyUrl2),\n      /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId2,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      new_params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info_2(new_params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info_2);\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaper) {\n  SetBypassDecode();\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER_CROPPED;\n  SimulateUserLogin(account_id_1);\n\n  // Verify that calling |SetOnlineWallpaper| will download the image data if it\n  // does not exist. Verify that the wallpaper is set successfully.\n  auto run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaper(\n      params, base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  // Verify that the user wallpaper info is updated.\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  // Verify that wallpaper & collection metrics are logged.\n  histogram_tester().ExpectBucketCount(\"Ash.Wallpaper.Image\", kUnitId, 1);\n  histogram_tester().ExpectBucketCount(\n      \"Ash.Wallpaper.Collection\",\n      static_cast<int>(base::PersistentHash(\n          TestWallpaperControllerClient::kDummyCollectionId)),\n      1);\n  histogram_tester().ExpectBucketCount(\"Ash.Wallpaper.Type\",\n                                       WallpaperType::kOnline, 1);\n\n  // Verify that the wallpaper with |url| is available offline, and the returned\n  // file name should not contain the small wallpaper suffix.\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->GetOfflineWallpaperList(base::BindLambdaForTesting(\n      [&run_loop](const std::vector<std::string>& url_list) {\n        EXPECT_EQ(1U, url_list.size());\n        EXPECT_EQ(GURL(kDummyUrl).ExtractFileName(), url_list[0]);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n}\n\nTEST_F(WallpaperControllerTest, SetAndRemovePolicyWallpaper) {\n  SetBypassDecode();\n  // Simulate the login screen.\n  ClearLogin();\n\n  // The user starts with no wallpaper info and is not controlled by policy.\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // A default wallpaper is shown for the user.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n\n  // Set a policy wallpaper. Verify that the user becomes policy controlled and\n  // the wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_1)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Verify the wallpaper is not updated since the user hasn't logged in.\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Log in the user. Verify the policy wallpaper is now being shown.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Clear the wallpaper and log out the user. Verify the policy wallpaper is\n  // shown in the login screen.\n  ClearWallpaper();\n  ClearLogin();\n  controller_->ClearPrefChangeObserverForTesting();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Remove the policy wallpaper. Verify the wallpaper info is reset to default\n  // and the user is no longer policy controlled.\n  ClearWallpaperCount();\n  controller_->RemovePolicyWallpaper(account_id_1);\n  WaitUntilCustomWallpapersDeleted(account_id_1);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  // Verify the wallpaper is not updated since the user hasn't logged in (to\n  // avoid abrupt wallpaper change in login screen).\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Log in the user. Verify the default wallpaper is now being shown.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n}\n\n// Simulates the scenario where the wallpaper are not yet resized and only the\n// original size image is available.\nTEST_F(WallpaperControllerTest, ShowUserWallpaper_OriginalFallback) {\n  SetBypassDecode();\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen.\n  ClearLogin();\n\n  // Set a wallpaper.\n  CreateAndSaveWallpapers(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was set.\n  WallpaperInfo wallpaper_info;\n  ASSERT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  ASSERT_EQ(WallpaperType::kCustomized, wallpaper_info.type);\n  ASSERT_EQ(\"user1@test.com-hash/user1@test.com-file\", wallpaper_info.location);\n\n  // Move the wallpaper file to the original folder.\n  base::FilePath saved_wallpaper = custom_wallpaper_dir_.GetPath().Append(\n      \"small/user1@test.com-hash/user1@test.com-file\");\n  ASSERT_TRUE(base::PathExists(saved_wallpaper));\n  base::CreateDirectory(\n      WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")\n          .Append(\"user1@test.com-hash\"));\n  ASSERT_TRUE(base::PathExists(\n      WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")));\n  ASSERT_TRUE(\n      base::Move(saved_wallpaper,\n                 WallpaperControllerImpl::GetCustomWallpaperDir(\"original\")\n                     .Append(wallpaper_info.location)));\n  ASSERT_FALSE(base::PathExists(saved_wallpaper));\n  ClearDecodeFilePaths();\n\n  // Show wallpaper\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was found in the original folder.\n  EXPECT_FALSE(GetDecodeFilePaths().empty());\n  EXPECT_THAT(\n      GetDecodeFilePaths().back().value(),\n      testing::EndsWith(\"original/user1@test.com-hash/user1@test.com-file\"));\n}\n\n// Simulates a missing wallpaper due (possibly) an outdated preference. In this\n// situation, we fallback to the default.\nTEST_F(WallpaperControllerTest, ShowUserWallpaper_MissingFile) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen.\n  ClearLogin();\n\n  // Set a wallpaper.\n  CreateAndSaveWallpapers(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the wallpaper was set.\n  WallpaperInfo wallpaper_info;\n  ASSERT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  ASSERT_EQ(WallpaperType::kCustomized, wallpaper_info.type);\n  ASSERT_EQ(\"user1@test.com-hash/user1@test.com-file\", wallpaper_info.location);\n\n  // Delete wallpaper file.\n  EXPECT_TRUE(base::DeleteFile(\n      user_data_dir_.GetPath().Append(wallpaper_info.location)));\n  ClearDecodeFilePaths();\n\n  // Show wallpaper\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  // Verify the default wallpaper was used because the stored wallpaper was\n  // missing.\n  EXPECT_FALSE(GetDecodeFilePaths().empty());\n  EXPECT_THAT(GetDecodeFilePaths().back().value(),\n              testing::EndsWith(kDefaultSmallWallpaperName));\n}\n\nTEST_F(WallpaperControllerTest, RemovePolicyWallpaperNoOp) {\n  auto verify_custom_wallpaper_info = [&]() {\n    EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n    EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n\n    WallpaperInfo wallpaper_info;\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    WallpaperInfo expected_wallpaper_info(\n        base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(),\n        WALLPAPER_LAYOUT_CENTER, WallpaperType::kCustomized,\n        base::Time::Now().LocalMidnight());\n    EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n  };\n\n  // Set a custom wallpaper. Verify the user is not policy controlled and the\n  // wallpaper info is correct.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(\n      account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER,\n      CreateImage(640, 480, kWallpaperColor), false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_FALSE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n  verify_custom_wallpaper_info();\n\n  // Verify RemovePolicyWallpaper() is a no-op when the user doesn't have a\n  // policy wallpaper.\n  controller_->RemovePolicyWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  verify_custom_wallpaper_info();\n}\n\nTEST_F(WallpaperControllerTest, SetThirdPartyWallpaper) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // Verify the user starts with no wallpaper info.\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Set a third-party wallpaper for |kUser1|.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia third_party_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  ClearWallpaperCount();\n  EXPECT_TRUE(controller_->SetThirdPartyWallpaper(\n      account_id_1, file_name_1, layout, third_party_wallpaper));\n  RunAllTasksUntilIdle();\n  // Verify the wallpaper is shown.\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Verify the user wallpaper info is updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n\n  // Switch active user to |kUser2|, but set another third-party wallpaper for\n  // |kUser1|; the operation should not be allowed, because |kUser1| is not the\n  // active user.\n  SimulateUserLogin(account_id_2);\n  ClearWallpaperCount();\n  EXPECT_FALSE(controller_->SetThirdPartyWallpaper(\n      account_id_1, file_name_2, layout, third_party_wallpaper));\n  // Verify the wallpaper is not shown.\n  EXPECT_EQ(0, GetWallpaperCount());\n  // Verify the wallpaper info for |kUser1| is updated, because setting\n  // wallpaper is still allowed for non-active users.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info_2(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_2).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info_2);\n\n  // Set a policy wallpaper for |kUser2|. Verify that |kUser2| becomes policy\n  // controlled.\n  controller_->SetPolicyWallpaper(account_id_2, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_2));\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Setting a third-party wallpaper for |kUser2| should not be allowed, because\n  // third-party wallpapers cannot be set for policy controlled users.\n  ClearWallpaperCount();\n  EXPECT_FALSE(controller_->SetThirdPartyWallpaper(\n      account_id_2, file_name_1, layout, third_party_wallpaper));\n  // Verify the wallpaper is not shown.\n  EXPECT_EQ(0, GetWallpaperCount());\n  // Verify |kUser2| is still policy controlled and has the policy wallpaper\n  // info.\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_2));\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_2, &wallpaper_info));\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_2)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForRegularAccount) {\n  CreateDefaultWallpapers();\n  SimulateUserLogin(account_id_1);\n\n  // First, simulate setting a user custom wallpaper.\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_NE(wallpaper_info.type, default_wallpaper_info.type);\n\n  // Verify |SetDefaultWallpaper| removes the previously set custom wallpaper\n  // info, and the large default wallpaper is set successfully with the correct\n  // file path.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n\n  SimulateSettingCustomWallpaper(account_id_1);\n  // Verify |SetDefaultWallpaper| removes the previously set custom wallpaper\n  // info, and the small default wallpaper is set successfully with the correct\n  // file path.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n\n  SimulateSettingCustomWallpaper(account_id_1);\n  // Verify that when screen is rotated, |SetDefaultWallpaper| removes the\n  // previously set custom wallpaper info, and the small default wallpaper is\n  // set successfully with the correct file path.\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  // The user wallpaper info has been reset to the default value.\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForChildAccount) {\n  CreateDefaultWallpapers();\n\n  SimulateUserLogin(kChildAccountId, user_manager::USER_TYPE_CHILD);\n\n  // Verify the large child wallpaper is set successfully with the correct file\n  // path.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(kChildAccountId, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kChildLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  // Verify the small child wallpaper is set successfully with the correct file\n  // path.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(kChildAccountId, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kChildSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\n// Verify that the |ShowWallpaperImage| will be called with the default image\n// for the guest session only even if there's a policy that has been set for\n// another user which invokes |SetPolicyWallpaper|.\nTEST_F(WallpaperControllerTest,\n       SetDefaultWallpaperForGuestSessionUnaffectedByWallpaperPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen.\n  ClearLogin();\n  CreateDefaultWallpapers();\n  ClearWallpaperCount();\n\n  // First, simulate settings for a guest user which will show the default\n  // wallpaper image by invoking |ShowWallpaperImage|.\n  SimulateGuestLogin();\n\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n\n  const AccountId guest_id =\n      AccountId::FromUserEmail(user_manager::kGuestUserName);\n  SimulateUserLogin(guest_id, user_manager::USER_TYPE_GUEST);\n  controller_->SetDefaultWallpaper(guest_id, /*show_wallpaper=*/true,\n                                   base::DoNothing());\n\n  WallpaperInfo wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  // Verify that the current displayed wallpaper is the default one inside the\n  // guest session.\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  // Second, set a user policy for which is being set for another\n  // user and verifying that the policy has been applied successfully.\n  WallpaperInfo policy_wallpaper_info;\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  /*data=*/std::string());\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                  &policy_wallpaper_info));\n  WallpaperInfo expected_policy_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1)\n          .Append(\"policy-controlled.jpeg\")\n          .value(),\n      WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kPolicy,\n      base::Time::Now().LocalMidnight());\n  EXPECT_EQ(policy_wallpaper_info, expected_policy_wallpaper_info);\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  // Finally, verifying that the guest session hasn't been affected by the new\n  // policy and |ShowWallpaperImage| hasn't been invoked another time.\n\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperForGuestSession) {\n  CreateDefaultWallpapers();\n\n  // First, simulate setting a custom wallpaper for a regular user.\n  SimulateUserLogin(account_id_1);\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_NE(wallpaper_info.type, default_wallpaper_info.type);\n\n  const AccountId guest_id =\n      AccountId::FromUserEmail(user_manager::kGuestUserName);\n  SimulateUserLogin(guest_id, user_manager::USER_TYPE_GUEST);\n\n  // Verify that during a guest session, |SetDefaultWallpaper| removes the user\n  // custom wallpaper info, but a guest specific wallpaper should be set,\n  // instead of the regular default wallpaper.\n  UpdateDisplay(\"1600x1200\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(guest_id, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(guest_id, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, default_wallpaper_info);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestLargeWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  controller_->SetDefaultWallpaper(guest_id, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kGuestSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\nTEST_F(WallpaperControllerTest, SetDefaultWallpaperCallbackTiming) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // First, simulate setting a user custom wallpaper.\n  SimulateSettingCustomWallpaper(account_id_1);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_NE(wallpaper_info.type, WallpaperType::kDefault);\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set default wallpaper and wait for success callback.\n  base::RunLoop loop;\n  controller_->SetDefaultWallpaper(\n      account_id_1, /*show_wallpaper=*/true,\n      base::BindLambdaForTesting([&loop, &observer](bool success) {\n        ASSERT_TRUE(success);\n        // Success callback should run before wallpaper observer is notified of\n        // change.\n        ASSERT_EQ(0, observer.wallpaper_changed_count());\n        loop.Quit();\n      }));\n  loop.Run();\n  // Wallpaper observer should have been notified of wallpaper change.\n  EXPECT_EQ(1, observer.wallpaper_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, IgnoreWallpaperRequestInKioskMode) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(\"kiosk\", user_manager::USER_TYPE_KIOSK_APP);\n\n  // Verify that |SetCustomWallpaper| doesn't set wallpaper in kiosk mode, and\n  // |account_id_1|'s wallpaper info is not updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  WallpaperInfo wallpaper_info;\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Verify that |SetOnlineWallpaperFromData| doesn't set wallpaper in kiosk\n  // mode, and |account_id_1|'s wallpaper info is not updated.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_FALSE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n\n  // Verify that |SetDefaultWallpaper| doesn't set wallpaper in kiosk mode, and\n  // |account_id_1|'s wallpaper info is not updated.\n  ClearWallpaperCount();\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_FALSE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n}\n\n// Disable the wallpaper setting for public session since it is ephemeral.\nTEST_F(WallpaperControllerTest, NotShowWallpaperSettingInPublicSession) {\n  SimulateUserLogin(\"public_session\", user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n  EXPECT_FALSE(controller_->ShouldShowWallpaperSetting());\n}\n\nTEST_F(WallpaperControllerTest, IgnoreWallpaperRequestWhenPolicyIsEnforced) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // Set a policy wallpaper for the user. Verify the user is policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  WallpaperInfo wallpaper_info;\n  WallpaperInfo policy_wallpaper_info(base::FilePath(wallpaper_files_id_1)\n                                          .Append(\"policy-controlled.jpeg\")\n                                          .value(),\n                                      WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                      WallpaperType::kPolicy,\n                                      base::Time::Now().LocalMidnight());\n\n  {\n    // Verify that |SetCustomWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                    WALLPAPER_LAYOUT_CENTER, image,\n                                    false /*preview_mode=*/);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetCustomWallpaper| with callback doesn't set wallpaper when\n    // policy is enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(\n        account_id_1, base::FilePath(file_name_1), WALLPAPER_LAYOUT_CENTER,\n        /*preview_mode=*/false,\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetOnlineWallpaperFromData| doesn't set wallpaper when\n    // policy is enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaperFromData(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(kDummyUrl),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        /*image_data=*/std::string(),\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetOnlineWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n    ClearWallpaperCount();\n    controller_->SetOnlineWallpaper(\n        OnlineWallpaperParams(\n            account_id_1, kAssetId, GURL(kDummyUrl),\n            /*collection_id=*/std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED,\n            /*preview_mode=*/false, /*from_user=*/false,\n            /*daily_refresh_enabled=*/false, kUnitId,\n            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n        base::BindLambdaForTesting([&run_loop](bool success) {\n          EXPECT_FALSE(success);\n          run_loop->Quit();\n        }));\n    run_loop->Run();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n\n  {\n    // Verify that |SetDefaultWallpaper| doesn't set wallpaper when policy is\n    // enforced, and the user wallpaper info is not updated.\n    ClearWallpaperCount();\n    controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                     base::DoNothing());\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(0, GetWallpaperCount());\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info, policy_wallpaper_info);\n  }\n}\n\nTEST_F(WallpaperControllerTest, VerifyWallpaperCache) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  SimulateUserLogin(account_id_1);\n\n  // |kUser1| doesn't have wallpaper cache in the beginning.\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetOnlineWallpaperFromData| updates wallpaper cache for |user1|.\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // After |kUser2| is logged in, |user1|'s wallpaper cache should still be kept\n  // (crbug.com/339576). Note the active user is still |user1|.\n  TestSessionControllerClient* session = GetSessionControllerClient();\n  session->AddUserSession(kUser2);\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetDefaultWallpaper| clears wallpaper cache.\n  controller_->SetDefaultWallpaper(account_id_1, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |SetCustomWallpaper| updates wallpaper cache for |user1|.\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Verify |RemoveUserWallpaper| clears wallpaper cache.\n  controller_->RemoveUserWallpaper(account_id_1);\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n}\n\n// Tests that the appropriate wallpaper (large vs. small) is shown depending\n// on the desktop resolution.\nTEST_F(WallpaperControllerTest, ShowCustomWallpaperWithCorrectResolution) {\n  CreateDefaultWallpapers();\n  const base::FilePath small_custom_wallpaper_path =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  const base::FilePath large_custom_wallpaper_path =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kLargeWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  const base::FilePath small_default_wallpaper_path =\n      default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName);\n  const base::FilePath large_default_wallpaper_path =\n      default_wallpaper_dir_.GetPath().Append(kDefaultLargeWallpaperName);\n\n  CreateAndSaveWallpapers(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  // Display is initialized to 800x600. The small resolution custom wallpaper is\n  // expected. A second decode request with small resolution default wallpaper\n  // is also expected. (Because unit tests don't support actual wallpaper\n  // decoding, it falls back to the default wallpaper.)\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(small_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(small_default_wallpaper_path, GetDecodeFilePaths()[1]);\n\n  // Hook up another 800x600 display. This shouldn't trigger a reload.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,800x600\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(0u, GetDecodeFilePaths().size());\n\n  // Detach the secondary display.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  // Hook up a 2000x2000 display. The large resolution custom wallpaper should\n  // be loaded.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,3000x2000\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(large_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(large_default_wallpaper_path, GetDecodeFilePaths()[1]);\n\n  // Detach the secondary display.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  // Hook up the 3000x2000 display again. The large resolution default wallpaper\n  // should persist. Test for crbug/165788.\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  UpdateDisplay(\"800x600,3000x2000\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(2u, GetDecodeFilePaths().size());\n  EXPECT_EQ(large_custom_wallpaper_path, GetDecodeFilePaths()[0]);\n  EXPECT_EQ(large_default_wallpaper_path, GetDecodeFilePaths()[1]);\n}\n\n// After the display is rotated, the sign in wallpaper should be kept. Test for\n// crbug.com/794725.\nTEST_F(WallpaperControllerTest, SigninWallpaperIsKeptAfterRotation) {\n  CreateDefaultWallpapers();\n\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  // Display is initialized to 800x600. The small resolution default wallpaper\n  // is expected.\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n\n  ClearWallpaperCount();\n  ClearDecodeFilePaths();\n  // After rotating the display, the small resolution default wallpaper should\n  // still be expected, instead of a custom wallpaper.\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ASSERT_EQ(1u, GetDecodeFilePaths().size());\n  EXPECT_EQ(default_wallpaper_dir_.GetPath().Append(kDefaultSmallWallpaperName),\n            GetDecodeFilePaths()[0]);\n}\n\n// Display size change should trigger wallpaper reload.\nTEST_F(WallpaperControllerTest, ReloadWallpaper) {\n  CreateAndSaveWallpapers(account_id_1);\n\n  // Show a user wallpaper.\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Calling |ShowUserWallpaper| again with the same account id and display\n  // size should not trigger wallpaper reload (crbug.com/158383).\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Start wallpaper preview.\n  SimulateUserLogin(account_id_1);\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(\n      account_id_1, file_name_1, WALLPAPER_LAYOUT_CENTER,\n      CreateImage(640, 480, kWallpaperColor), true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show an always-on-top wallpaper.\n  const base::FilePath image_path =\n      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(\n          switches::kGuestWallpaperLarge);\n  CreateDefaultWallpapers();\n  SetBypassDecode();\n  ClearWallpaperCount();\n  controller_->ShowAlwaysOnTopWallpaper(image_path);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  // Rotating the display should trigger a wallpaper reload.\n  ClearWallpaperCount();\n  UpdateDisplay(\"800x600/r\");\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, UpdateCurrentWallpaperLayout) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kSmallCustomWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  WallpaperLayout new_layout = WALLPAPER_LAYOUT_CENTER;\n  SimulateUserLogin(account_id_1);\n\n  // Set a custom wallpaper for the user. Verify that it's set successfully\n  // and the wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_custom_wallpaper_info);\n\n  // Now change to a different layout. Verify that the layout is updated for\n  // both the current wallpaper and the saved wallpaper info.\n  ClearWallpaperCount();\n  controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), new_layout);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  expected_custom_wallpaper_info.layout = new_layout;\n  EXPECT_EQ(wallpaper_info, expected_custom_wallpaper_info);\n\n  {\n    base::test::ScopedFeatureList scoped_feature_list;\n    scoped_feature_list.InitWithFeatures(\n        {ash::features::kWallpaperGooglePhotosIntegration}, {});\n\n    // Now set a Google Photos wallpaper. Verify that it's set successfully and\n    // the wallpaper info is updated.\n    ClearWallpaperCount();\n    controller_->SetGooglePhotosWallpaper(\n        GooglePhotosWallpaperParams(account_id_1, \"id\",\n                                    /*daily_refresh_enabled=*/false, layout,\n                                    /*preview_mode=*/false, \"dedup_key\"),\n        base::DoNothing());\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(1, GetWallpaperCount());\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n    EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info,\n              WallpaperInfo(GooglePhotosWallpaperParams(\n                  account_id_1, \"id\", /*daily_refresh_enabled=*/false, layout,\n                  /*preview_mode=*/false, \"dedup_key\")));\n\n    // Now change to a different layout. Verify that the layout is updated for\n    // both the current wallpaper and the saved wallpaper info.\n    ClearWallpaperCount();\n    controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(1, GetWallpaperCount());\n    EXPECT_EQ(controller_->GetWallpaperLayout(), new_layout);\n    EXPECT_TRUE(\n        pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n    EXPECT_EQ(wallpaper_info,\n              WallpaperInfo(GooglePhotosWallpaperParams(\n                  account_id_1, \"id\", /*daily_refresh_enabled=*/false,\n                  new_layout, /*preview_mode=*/false, \"dedup_key\")));\n  }\n\n  // Now set an online wallpaper. Verify that it's set successfully and the\n  // wallpaper info is updated.\n  image = CreateImage(640, 480, kWallpaperColor);\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(), layout,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>());\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_online_wallpaper_info(params);\n  EXPECT_EQ(wallpaper_info, expected_online_wallpaper_info);\n\n  // Now change the layout of the online wallpaper. Verify that it's a no-op.\n  ClearWallpaperCount();\n  controller_->UpdateCurrentWallpaperLayout(account_id_1, new_layout);\n  RunAllTasksUntilIdle();\n  // The wallpaper is not updated.\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperLayout(), layout);\n  // The saved wallpaper info is not updated.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, expected_online_wallpaper_info);\n}\n\n// Tests that if a user who has a custom wallpaper is removed from the device,\n// only the directory that contains the user's custom wallpapers gets removed.\n// The other user's custom wallpaper is not affected.\nTEST_F(WallpaperControllerTest, RemoveUserWithCustomWallpaper) {\n  SimulateUserLogin(account_id_1);\n  base::FilePath small_wallpaper_path_1 =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n\n  // Set a custom wallpaper for |kUser1| and verify the wallpaper exists.\n  CreateAndSaveWallpapers(account_id_1);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n\n  // Now login another user and set a custom wallpaper for the user.\n  SimulateUserLogin(account_id_2);\n  base::FilePath small_wallpaper_path_2 = GetCustomWallpaperPath(\n      WallpaperControllerImpl::kSmallWallpaperSubDir, wallpaper_files_id_2,\n      GetDummyFileName(account_id_2));\n  CreateAndSaveWallpapers(account_id_2);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_2));\n\n  // Simulate the removal of |kUser2|.\n  controller_->RemoveUserWallpaper(account_id_2);\n  // Wait until all files under the user's custom wallpaper directory are\n  // removed.\n  WaitUntilCustomWallpapersDeleted(account_id_2);\n  EXPECT_FALSE(base::PathExists(small_wallpaper_path_2));\n\n  // Verify that the other user's wallpaper is not affected.\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n}\n\n// Tests that if a user who has a default wallpaper is removed from the device,\n// the other user's custom wallpaper is not affected.\nTEST_F(WallpaperControllerTest, RemoveUserWithDefaultWallpaper) {\n  SimulateUserLogin(account_id_1);\n  base::FilePath small_wallpaper_path_1 =\n      GetCustomWallpaperPath(WallpaperControllerImpl::kSmallWallpaperSubDir,\n                             wallpaper_files_id_1, file_name_1);\n  // Set a custom wallpaper for |kUser1| and verify the wallpaper exists.\n  CreateAndSaveWallpapers(account_id_1);\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n\n  // Now login another user and set a default wallpaper for the user.\n  SimulateUserLogin(account_id_2);\n  controller_->SetDefaultWallpaper(account_id_2, true /*show_wallpaper=*/,\n                                   base::DoNothing());\n\n  // Simulate the removal of |kUser2|.\n  controller_->RemoveUserWallpaper(account_id_2);\n\n  // Verify that the other user's wallpaper is not affected.\n  EXPECT_TRUE(base::PathExists(small_wallpaper_path_1));\n}\n\nTEST_F(WallpaperControllerTest, IsActiveUserWallpaperControlledByPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen. Verify that it returns false since there's no\n  // active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  SimulateUserLogin(account_id_1);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n  // Set a policy wallpaper for the active user. Verify that the active user\n  // becomes policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1, user_manager::USER_TYPE_REGULAR,\n                                  std::string() /*data=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Switch the active user. Verify the active user is not policy controlled.\n  SimulateUserLogin(account_id_2);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Logs out. Verify that it returns false since there's no active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n}\n\nTEST_F(WallpaperControllerTest,\n       IsManagedGuestSessionWallpaperControlledByPolicy) {\n  SetBypassDecode();\n  // Simulate the login screen. Verify that it returns false since there's no\n  // active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Set a policy wallpaper for the managed guest session. Verify that the\n  // managed guest session becomes policy controlled.\n  controller_->SetPolicyWallpaper(account_id_1,\n                                  user_manager::USER_TYPE_PUBLIC_ACCOUNT,\n                                  std::string() /*data=*/);\n  SimulateUserLogin(account_id_1, user_manager::USER_TYPE_PUBLIC_ACCOUNT);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->IsWallpaperControlledByPolicy(account_id_1));\n\n  // Verify the wallpaper policy is applied after logging in.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  EXPECT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kPolicy);\n\n  // Switch the active user. Verify the active user is not policy controlled.\n  SimulateUserLogin(account_id_2);\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n\n  // Logs out. Verify that it returns false since there's no active user.\n  ClearLogin();\n  EXPECT_FALSE(controller_->IsActiveUserWallpaperControlledByPolicy());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperBlur) {\n  TestWallpaperControllerObserver observer(controller_);\n\n  ASSERT_TRUE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(0, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(1, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(2, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  // Blur state does not change below.\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  SetSessionState(SessionState::OOBE);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n\n  SetSessionState(SessionState::UNKNOWN);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(3, observer.blur_changed_count());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperBlurDuringLockScreenTransition) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n\n  gfx::ImageSkia image = CreateImage(600, 400, kWallpaperColor);\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  ASSERT_TRUE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n\n  // Simulate lock and unlock sequence.\n  controller_->UpdateWallpaperBlurForLockState(true);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(1, observer.blur_changed_count());\n\n  SetSessionState(SessionState::LOCKED);\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n  ASSERT_EQ(3u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_SOLID_COLOR,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[2]->type());\n\n  // Change of state to ACTIVE triggers post lock animation and\n  // UpdateWallpaperBlur(false)\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(2, observer.blur_changed_count());\n  ASSERT_EQ(2u, wallpaper_view()->layer()->parent()->children().size());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[0]->type());\n  EXPECT_EQ(ui::LAYER_TEXTURED,\n            wallpaper_view()->layer()->parent()->children()[1]->type());\n}\n\nTEST_F(WallpaperControllerTest, LockDuringOverview) {\n  gfx::ImageSkia image = CreateImage(600, 400, kWallpaperColor);\n  controller_->ShowWallpaperImage(\n      image, CreateWallpaperInfo(WALLPAPER_LAYOUT_CENTER),\n      /*preview_mode=*/false, /*always_on_top=*/false);\n  TestWallpaperControllerObserver observer(controller_);\n\n  EnterOverview();\n\n  EXPECT_FALSE(controller_->IsWallpaperBlurredForLockState());\n  EXPECT_EQ(0, observer.blur_changed_count());\n\n  // Simulate lock and unlock sequence.\n  SetSessionState(SessionState::LOCKED);\n\n  EXPECT_TRUE(controller_->IsWallpaperBlurredForLockState());\n\n  // Get wallpaper_view directly because it's not animating.\n  auto* wallpaper_view = Shell::Get()\n                             ->GetPrimaryRootWindowController()\n                             ->wallpaper_widget_controller()\n                             ->wallpaper_view();\n\n  // Make sure that wallpaper still have blur.\n  ASSERT_EQ(30, wallpaper_view->blur_sigma());\n}\n\nTEST_F(WallpaperControllerTest, DontLeakShieldView) {\n  SetSessionState(SessionState::LOCKED);\n  views::View* shield_view = wallpaper_view()->shield_view_for_testing();\n  ASSERT_TRUE(shield_view);\n  views::ViewTracker view_tracker(shield_view);\n  SetSessionState(SessionState::ACTIVE);\n  EXPECT_EQ(nullptr, wallpaper_view()->shield_view_for_testing());\n  EXPECT_EQ(nullptr, view_tracker.view());\n}\n\nTEST_F(WallpaperControllerTest, OnlyShowDevicePolicyWallpaperOnLoginScreen) {\n  SetBypassDecode();\n\n  // Verify the device policy wallpaper is shown on login screen.\n  SetSessionState(SessionState::LOGIN_PRIMARY);\n  controller_->SetDevicePolicyWallpaperPath(\n      base::FilePath(kDefaultSmallWallpaperName));\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_TRUE(IsDevicePolicyWallpaper());\n  // Verify the device policy wallpaper shouldn't be blurred.\n  ASSERT_FALSE(controller_->IsBlurAllowedForLockState());\n  ASSERT_FALSE(controller_->IsWallpaperBlurredForLockState());\n\n  // Verify the device policy wallpaper is replaced when session state is no\n  // longer LOGIN_PRIMARY.\n  SetSessionState(SessionState::LOGGED_IN_NOT_ACTIVE);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  // Verify the device policy wallpaper never shows up again when session\n  // state changes.\n  SetSessionState(SessionState::ACTIVE);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  SetSessionState(SessionState::LOCKED);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n\n  SetSessionState(SessionState::LOGIN_SECONDARY);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_FALSE(IsDevicePolicyWallpaper());\n}\n\nTEST_F(WallpaperControllerTest, ShouldShowInitialAnimationAfterBoot) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen after system boot.\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(\n      switches::kFirstExecAfterBoot);\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(switches::kLoginManager);\n  ClearLogin();\n\n  // Show the first wallpaper. Verify that the slower animation should be used.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show the second wallpaper. Verify that the slower animation should not be\n  // used. (Use a different user type to ensure a different wallpaper is shown,\n  // otherwise requests of loading the same wallpaper are ignored.)\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(kChildAccountId);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Log in the user and show the wallpaper. Verify that the slower animation\n  // should not be used.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, ShouldNotShowInitialAnimationAfterSignOut) {\n  CreateDefaultWallpapers();\n\n  // Simulate the login screen after user sign-out. Verify that the slower\n  // animation should never be used.\n  base::CommandLine::ForCurrentProcess()->AppendSwitch(switches::kLoginManager);\n  CreateAndSaveWallpapers(account_id_1);\n  ClearLogin();\n\n  // Show the first wallpaper.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Show the second wallpaper.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(kChildAccountId);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n\n  // Log in the user and show the wallpaper.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(controller_->ShouldShowInitialAnimation());\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, ClosePreviewWallpaperOnOverviewStart) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n\n  TestWallpaperControllerObserver observer(controller_);\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now enter overview mode. Verify the wallpaper changes back to the default,\n  // the user wallpaper info remains unchanged, and enters overview mode\n  // properly.\n  ClearWallpaperCount();\n  EnterOverview();\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  EXPECT_TRUE(Shell::Get()->overview_controller()->InOverviewSession());\n}\n\nTEST_F(WallpaperControllerTest, ClosePreviewWallpaperOnWindowCycleStart) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now start window cycle. Verify the wallpaper changes back to the default,\n  // the user wallpaper info remains unchanged, and enters window cycle.\n  ClearWallpaperCount();\n  Shell::Get()->window_cycle_controller()->HandleCycleWindow(\n      WindowCycleController::WindowCyclingDirection::kForward);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  EXPECT_TRUE(Shell::Get()->window_cycle_controller()->IsCycling());\n}\n\nTEST_F(WallpaperControllerTest,\n       ClosePreviewWallpaperOnActiveUserSessionChanged) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  TestWallpaperControllerObserver observer(controller_);\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_TRUE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now switch to another user. Verify the wallpaper changes back to the\n  // default and the user wallpaper remains unchanged.\n  ClearWallpaperCount();\n  SimulateUserLogin(account_id_2);\n  controller_->ShowUserWallpaper(account_id_2);\n  RunAllTasksUntilIdle();\n  EXPECT_FALSE(observer.is_in_wallpaper_preview());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_2, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, ConfirmPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\", 1);\n\n  // Now confirm the preview wallpaper, verify that there's no wallpaper change\n  // because the wallpaper is already shown.\n  ClearWallpaperCount();\n  controller_->ConfirmPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n\n  // Verify that the user wallpaper info is now updated to the custom wallpaper\n  // info.\n  WallpaperInfo custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, custom_wallpaper_info);\n\n  // Set an empty online wallpaper for the user, verify it fails.\n  ClearWallpaperCount();\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, gfx::ImageSkia(), kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_FALSE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Now set a valid online wallpaper for the user and enable preview. Verify\n  // that the wallpaper is changed to the expected color.\n  const SkColor online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia online_wallpaper =\n      CreateImage(640, 480, online_wallpaper_color);\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  run_loop = std::make_unique<base::RunLoop>();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/\n      std::vector<OnlineWallpaperVariant>(),\n      base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, custom_wallpaper_info);\n\n  // Now confirm the preview wallpaper, verify that there's no wallpaper change\n  // because the wallpaper is already shown.\n  ClearWallpaperCount();\n  controller_->ConfirmPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info is now updated to the online wallpaper\n  // info.\n  WallpaperInfo online_wallpaper_info(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false,\n      /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/\n      std::vector<OnlineWallpaperVariant>()));\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, online_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, CancelPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now cancel the preview. Verify the wallpaper changes back to the default\n  // and the user wallpaper info remains unchanged.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now set an online wallpaper for the user and enable preview. Verify that\n  // the wallpaper is changed to the expected color.\n  const SkColor online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia online_wallpaper =\n      CreateImage(640, 480, online_wallpaper_color);\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(online_wallpaper_color, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now cancel the preview. Verify the wallpaper changes back to the default\n  // and the user wallpaper info remains unchanged.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_NE(online_wallpaper_color, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, WallpaperSyncedDuringPreview) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a custom wallpaper for the user and enable preview. Verify that the\n  // wallpaper is changed to the expected color.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, true /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Now set another custom wallpaper for the user and disable preview (this\n  // happens if a custom wallpaper set on another device is being synced).\n  // Verify there's no wallpaper change since preview mode shouldn't be\n  // interrupted.\n  const SkColor synced_custom_wallpaper_color = SK_ColorBLUE;\n  gfx::ImageSkia synced_custom_wallpaper =\n      CreateImage(640, 480, synced_custom_wallpaper_color);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_2, layout,\n                                  synced_custom_wallpaper,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // However, the user wallpaper info should already be updated to the new info.\n  WallpaperInfo synced_custom_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_2).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Now cancel the preview. Verify the synced custom wallpaper is shown instead\n  // of the initial default wallpaper, and the user wallpaper info is still\n  // correct.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(synced_custom_wallpaper_color, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Repeat the above steps for online wallpapers: set a online wallpaper for\n  // the user and enable preview. Verify that the wallpaper is changed to the\n  // expected color.\n  gfx::ImageSkia online_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  EXPECT_NE(kWallpaperColor, GetWallpaperColor());\n\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, online_wallpaper, kDummyUrl,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/true, /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n  // Now set another online wallpaper for the user and disable preview. Verify\n  // there's no wallpaper change since preview mode shouldn't be interrupted.\n  const SkColor synced_online_wallpaper_color = SK_ColorCYAN;\n  gfx::ImageSkia synced_online_wallpaper =\n      CreateImage(640, 480, synced_online_wallpaper_color);\n  ClearWallpaperCount();\n  SetOnlineWallpaperFromImage(\n      account_id_1, kAssetId, synced_online_wallpaper, kDummyUrl2,\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*save_file=*/false, /*preview_mode=*/false,\n      /*from_user=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // However, the user wallpaper info should already be updated to the new info.\n  WallpaperInfo synced_online_wallpaper_info =\n      WallpaperInfo(OnlineWallpaperParams(\n          account_id_1, kAssetId, GURL(kDummyUrl2),\n          TestWallpaperControllerClient::kDummyCollectionId, layout,\n          /*preview_mode=*/false,\n          /*from_user=*/true,\n          /*daily_refresh_enabled=*/false, kUnitId,\n          /*variants=*/\n          std::vector<OnlineWallpaperVariant>()));\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_online_wallpaper_info);\n\n  // Now cancel the preview. Verify the synced online wallpaper is shown instead\n  // of the previous custom wallpaper, and the user wallpaper info is still\n  // correct.\n  ClearWallpaperCount();\n  controller_->CancelPreviewWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(synced_online_wallpaper_color, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, synced_online_wallpaper_info);\n}\n\nTEST_F(WallpaperControllerTest, AddFirstWallpaperAnimationEndCallback) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n  std::unique_ptr<aura::Window> test_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n\n  base::RunLoop test_loop;\n  controller_->AddFirstWallpaperAnimationEndCallback(test_loop.QuitClosure(),\n                                                     test_window.get());\n  // The callback is not run because the first wallpaper hasn't been set.\n  task_environment()->RunUntilIdle();\n  EXPECT_FALSE(test_loop.AnyQuitCalled());\n\n  // Set the first wallpaper.\n  controller_->ShowDefaultWallpaperForTesting();\n  controller_->AddFirstWallpaperAnimationEndCallback(test_loop.QuitClosure(),\n                                                     test_window.get());\n  task_environment()->RunUntilIdle();\n  // Neither callback is run because the animation of the first wallpaper\n  // hasn't finished yet.\n  EXPECT_FALSE(test_loop.AnyQuitCalled());\n\n  // Force the animation to complete. The two callbacks are both run.\n  RunDesktopControllerAnimation();\n  test_loop.Run();\n  EXPECT_TRUE(test_loop.AnyQuitCalled());\n\n  // The callback added after the first wallpaper animation is run right away.\n  bool is_third_callback_run = false;\n  controller_->AddFirstWallpaperAnimationEndCallback(\n      base::BindLambdaForTesting(\n          [&is_third_callback_run]() { is_third_callback_run = true; }),\n      test_window.get());\n  EXPECT_TRUE(is_third_callback_run);\n}\n\nTEST_F(WallpaperControllerTest, ShowOneShotWallpaper) {\n  gfx::ImageSkia custom_wallpaper = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n  // First, set a custom wallpaper for |kUser1|. Verify the wallpaper is shown\n  // successfully and the user wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  custom_wallpaper, false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  const WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n\n  // Show a one-shot wallpaper. Verify it is shown successfully.\n  ClearWallpaperCount();\n  constexpr SkColor kOneShotWallpaperColor = SK_ColorWHITE;\n  gfx::ImageSkia one_shot_wallpaper =\n      CreateImage(640, 480, kOneShotWallpaperColor);\n  controller_->ShowOneShotWallpaper(one_shot_wallpaper);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kOneShotWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kOneShot, controller_->GetWallpaperType());\n  EXPECT_FALSE(controller_->IsBlurAllowedForLockState());\n  EXPECT_FALSE(controller_->ShouldApplyShield());\n\n  // Verify that we can reload wallpaer without losing it.\n  // This is important for screen rotation.\n  controller_->ReloadWallpaperForTesting(/*clear_cache=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());  // Reload increments count.\n  EXPECT_EQ(kOneShotWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kOneShot, controller_->GetWallpaperType());\n  EXPECT_FALSE(controller_->IsBlurAllowedForLockState());\n  EXPECT_FALSE(controller_->ShouldApplyShield());\n\n  // Verify the user wallpaper info is unaffected, and the one-shot wallpaper\n  // can be replaced by the user wallpaper.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(expected_wallpaper_info, wallpaper_info);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n}\n\nTEST_F(WallpaperControllerTest, OnFirstWallpaperShown) {\n  TestWallpaperControllerObserver observer(controller_);\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(0, observer.first_shown_count());\n  // Show the first wallpaper, verify the observer is notified.\n  controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorBLUE),\n                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n                                  /*preview_mode=*/false,\n                                  /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(SK_ColorBLUE, GetWallpaperColor());\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(1, observer.first_shown_count());\n  // Show the second wallpaper, verify the observer is not notified.\n  controller_->ShowWallpaperImage(CreateImage(640, 480, SK_ColorCYAN),\n                                  CreateWallpaperInfo(WALLPAPER_LAYOUT_STRETCH),\n                                  /*preview_mode=*/false,\n                                  /*always_on_top=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(SK_ColorCYAN, GetWallpaperColor());\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(1, observer.first_shown_count());\n}\n\n// Although ephemeral users' custom wallpapers are not saved to disk, they\n// should be kept within the user session. Test for https://crbug.com/825237.\nTEST_F(WallpaperControllerTest, ShowWallpaperForEphemeralUser) {\n  // Clear the local pref so we can make sure nothing writes to it.\n  local_state()->ClearPref(prefs::kUserWallpaperInfo);\n\n  // Add an ephemeral user session and simulate login, like SimulateUserLogin.\n  UserSession session;\n  session.session_id = 0;\n  session.user_info.account_id = account_id_1;\n  session.user_info.is_ephemeral = true;\n  Shell::Get()->session_controller()->UpdateUserSession(std::move(session));\n  TestSessionControllerClient* const client = GetSessionControllerClient();\n  client->SwitchActiveUser(account_id_1);\n  client->SetSessionState(SessionState::ACTIVE);\n\n  // The user doesn't have wallpaper cache in the beginning.\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1,\n                                  WALLPAPER_LAYOUT_CENTER,\n                                  CreateImage(640, 480, kWallpaperColor),\n                                  /*preview_mode=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  // Assert that we do not use local state for an ephemeral user.\n  auto* dict = local_state()->GetUserPrefValue(prefs::kUserWallpaperInfo);\n  ASSERT_FALSE(dict) << *dict;\n\n  // The custom wallpaper is cached.\n  EXPECT_TRUE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n  EXPECT_EQ(\n      kWallpaperColor,\n      cached_wallpaper.GetRepresentation(1.0f).GetBitmap().getColor(0, 0));\n  EXPECT_TRUE(controller_->GetPathFromCache(account_id_1, &path));\n\n  // Calling |ShowUserWallpaper| will continue showing the custom wallpaper\n  // instead of reverting to the default.\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(WallpaperType::kCustomized, controller_->GetWallpaperType());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n}\n\nTEST_F(WallpaperControllerTest, AlwaysOnTopWallpaper) {\n  CreateDefaultWallpapers();\n  SetBypassDecode();\n\n  // Show a default wallpaper.\n  EXPECT_EQ(0, GetWallpaperCount());\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Show an always-on-top wallpaper.\n  const base::FilePath image_path =\n      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(\n          switches::kGuestWallpaperLarge);\n  controller_->ShowAlwaysOnTopWallpaper(image_path);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOneShot);\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Subsequent wallpaper requests are ignored when the current wallpaper is\n  // always-on-top.\n  controller_->ShowSigninWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOneShot);\n  EXPECT_EQ(0, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(1, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // The wallpaper reverts to the default after the always-on-top wallpaper is\n  // removed.\n  controller_->RemoveAlwaysOnTopWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(3, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n\n  // Calling |RemoveAlwaysOnTopWallpaper| is a no-op when the current wallpaper\n  // is not always-on-top.\n  controller_->RemoveAlwaysOnTopWallpaper();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(3, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  EXPECT_EQ(1, ChildCountForContainer(kWallpaperId));\n  EXPECT_EQ(0, ChildCountForContainer(kAlwaysOnTopWallpaperId));\n}\n\nnamespace {\n\nclass WallpaperControllerPrefTest : public AshTestBase {\n public:\n  WallpaperControllerPrefTest() {\n    base::Value::Dict property;\n    property.Set(\"rotation\", static_cast<int>(display::Display::ROTATE_90));\n    property.Set(\"width\", 800);\n    property.Set(\"height\", 600);\n\n    DictionaryPrefUpdate update(local_state(), prefs::kDisplayProperties);\n    update.Get()->SetKey(\"2200000000\", base::Value(std::move(property)));\n  }\n\n  ~WallpaperControllerPrefTest() override = default;\n\n  void SetUp() override { AshTestBase::SetUp(); }\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\n}  // namespace\n\n// Make sure that the display and the wallpaper view are rotated correctly at\n// startup.\nTEST_F(WallpaperControllerPrefTest, InitWithPrefs) {\n  auto* wallpaper_view = Shell::GetPrimaryRootWindowController()\n                             ->wallpaper_widget_controller()\n                             ->wallpaper_view();\n  auto* root_window =\n      wallpaper_view->GetWidget()->GetNativeWindow()->GetRootWindow();\n\n  EXPECT_EQ(gfx::Size(600, 800), display::Screen::GetScreen()\n                                     ->GetDisplayNearestWindow(root_window)\n                                     .size());\n  EXPECT_EQ(root_window->bounds().size(), wallpaper_view->bounds().size());\n}\n\nTEST_F(WallpaperControllerTest, NoAnimationForNewRootWindowWhenLocked) {\n  ui::ScopedAnimationDurationScaleMode test_duration_mode(\n      ui::ScopedAnimationDurationScaleMode::NON_ZERO_DURATION);\n  SetSessionState(SessionState::LOCKED);\n  UpdateDisplay(\"800x600, 800x600\");\n  auto* secondary_root_window_controller =\n      Shell::Get()->GetAllRootWindowControllers()[1];\n  EXPECT_FALSE(secondary_root_window_controller->wallpaper_widget_controller()\n                   ->IsAnimating());\n  EXPECT_FALSE(secondary_root_window_controller->wallpaper_widget_controller()\n                   ->GetWidget()\n                   ->GetLayer()\n                   ->GetAnimator()\n                   ->is_animating());\n}\n\nTEST_F(WallpaperControllerTest, SetCustomWallpaper) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n\n  // Set a custom wallpaper for |kUser1|. Verify the wallpaper is set\n  // successfully and wallpaper info is updated.\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(\n      base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(), layout,\n      WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n\n  // Now set another custom wallpaper for |kUser1|. Verify that the on-screen\n  // wallpaper doesn't change since |kUser1| is not active, but wallpaper info\n  // is updated properly.\n  SimulateUserLogin(account_id_2);\n  const SkColor custom_wallpaper_color = SK_ColorCYAN;\n  image = CreateImage(640, 480, custom_wallpaper_color);\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_EQ(kWallpaperColor, GetWallpaperColor());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Verify the updated wallpaper is shown after |kUser1| becomes active again.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(custom_wallpaper_color, GetWallpaperColor());\n}\n\nTEST_F(WallpaperControllerTest, OldOnlineInfoSynced_Discarded) {\n  // Create a dictionary that looks like the preference from crrev.com/a040384.\n  // DO NOT CHANGE as there are preferences like this in production.\n  base::Value::Dict wallpaper_info_dict;\n  wallpaper_info_dict.Set(\n      WallpaperPrefManager::kNewWallpaperDateNodeName,\n      base::NumberToString(\n          base::Time::Now().ToDeltaSinceWindowsEpoch().InMicroseconds()));\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperLocationNodeName,\n                          \"location\");\n  wallpaper_info_dict.Set(\n      WallpaperPrefManager::kNewWallpaperUserFilePathNodeName,\n      \"user_file_path\");\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperLayoutNodeName,\n                          WallpaperLayout::WALLPAPER_LAYOUT_CENTER);\n  wallpaper_info_dict.Set(WallpaperPrefManager::kNewWallpaperTypeNodeName,\n                          static_cast<int>(WallpaperType::kOnline));\n\n  {\n    DictionaryPrefUpdate wallpaper_update(GetProfilePrefService(account_id_1),\n                                          prefs::kSyncableWallpaperInfo);\n    wallpaper_update->SetKey(account_id_1.GetUserEmail(),\n                             base::Value(std::move(wallpaper_info_dict)));\n  }\n  SimulateUserLogin(account_id_1);\n  task_environment()->RunUntilIdle();\n\n  // Unmigrated synced wallpaper info are discarded.\n  WallpaperInfo actual;\n  EXPECT_FALSE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfo_Online) {\n  WallpaperInfo expected_info = InfoWithType(WallpaperType::kOnline);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfoCustomized) {\n  WallpaperInfo expected_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n}\n\nTEST_F(WallpaperControllerTest, MigrateWallpaperInfoDaily) {\n  WallpaperInfo expected_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, expected_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  EXPECT_EQ(expected_info, info);\n  EXPECT_EQ(client_.migrate_collection_id_from_chrome_app_count(), 1u);\n}\n\nTEST_F(WallpaperControllerTest,\n       MigrateWallpaperInfoDoesntHappenWhenSyncedInfoAlreadyExists) {\n  SetBypassDecode();\n\n  WallpaperInfo local_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  WallpaperInfo synced_info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId2, GURL(kDummyUrl2),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info;\n  ASSERT_TRUE(pref_manager_->GetSyncedWallpaperInfo(account_id_1, &info));\n  // Synced info should be the same if local is the same age.\n  EXPECT_EQ(synced_info, info);\n}\n\nTEST_F(WallpaperControllerTest,\n       ActiveUserPrefServiceChangedSyncedInfoHandledLocally) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  client_.ResetCounts();\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n  RunAllTasksUntilIdle();\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, ActiveUserPrefServiceChanged_SyncDisabled) {\n  CacheOnlineWallpaper(kDummyUrl);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  client_.ResetCounts();\n\n  client_.set_wallpaper_sync_enabled(false);\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kThirdParty, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedLocalIsPolicy) {\n  CacheOnlineWallpaper(kDummyUrl);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1,\n                                       InfoWithType(WallpaperType::kPolicy));\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_NE(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedLocalIsThirdPartyAndOlder) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kThirdParty);\n  local_info.date = DayBeforeYesterdayish();\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, base::Time::Now()};\n  synced_info.asset_id = kAssetId;\n  synced_info.collection_id = TestWallpaperControllerClient::kDummyCollectionId;\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kOnline, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedLocalIsThirdPartyAndNewer) {\n  CacheOnlineWallpaper(kDummyUrl);\n  pref_manager_->SetLocalWallpaperInfo(\n      account_id_1, InfoWithType(WallpaperType::kThirdParty));\n\n  WallpaperInfo synced_info = {kDummyUrl, WALLPAPER_LAYOUT_CENTER_CROPPED,\n                               WallpaperType::kOnline, DayBeforeYesterdayish()};\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(WallpaperType::kThirdParty, actual_info.type);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedOnline) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  // Attempt to set an online wallpaper without providing the image data. Verify\n  // it succeeds this time because |SetOnlineWallpaperFromData| has saved the\n  // file.\n  ClearWallpaperCount();\n  WallpaperInfo info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER, /*preview_mode=*/false, /*from_user=*/false,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      std::vector<OnlineWallpaperVariant>()));\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, info);\n\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest, HandleWallpaperInfoSyncedInactiveUser) {\n  CacheOnlineWallpaper(kDummyUrl);\n\n  // Make account_id_1 the inactive user.\n  SimulateUserLogin(account_id_2);\n\n  // Attempt to set an online wallpaper without providing the image data. Verify\n  // it succeeds this time because |SetOnlineWallpaperFromData| has saved the\n  // file.\n  ClearWallpaperCount();\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1,\n                                        InfoWithType(WallpaperType::kOnline));\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(0, GetWallpaperCount());\n  EXPECT_NE(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper) {\n  std::string expected{\"fun_collection\"};\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.asset_id = kAssetId;\n  info.collection_id = expected;\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(expected, client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\n// Disabled due to flakes; see crbug/1320991.\nTEST_F(WallpaperControllerTest,\n       DISABLED_UpdateDailyRefreshWallpaperCalledOnLogin) {\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*from_user=*/false,\n      /*daily_refresh_enabled=*/true, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>()));\n  info.date = DayBeforeYesterdayish();\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  ClearLogin();\n  SimulateUserLogin(account_id_1);\n\n  // Info is set as over a day old so we expect one task to run in under an hour\n  // (due to fuzzing) then it will idle.\n  task_environment()->FastForwardBy(base::Hours(1));\n\n  EXPECT_EQ(TestWallpaperControllerClient::kDummyCollectionId,\n            client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper_NotEnabled) {\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kOnline, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(std::string(), client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest, UpdateDailyRefreshWallpaper_NoCollectionId) {\n  SimulateUserLogin(account_id_1);\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kDaily, DayBeforeYesterdayish()));\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  EXPECT_EQ(std::string(), client_.get_fetch_daily_refresh_wallpaper_param());\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_TimerStartsOnPrefServiceChange) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily,\n                        base::Time::Now().LocalMidnight()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->OnActiveUserPrefServiceChanged(\n      GetProfilePrefService(account_id_1));\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delta = run_time.ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      Time::Now().LocalMidnight().ToDeltaSinceWindowsEpoch() + base::Days(1);\n\n  ASSERT_GE(delta, update_time - base::Minutes(1));\n  ASSERT_LE(delta, update_time + base::Hours(1) + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_RetryTimerTriggersOnFailedFetchInfo) {\n  using base::Time;\n\n  client_.set_fetch_daily_refresh_info_fails(true);\n\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n  // Lave a little wiggle room.\n  ASSERT_GE(delay, one_hour - base::Minutes(1));\n  ASSERT_LE(delay, one_hour + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateDailyRefreshWallpaper_RetryTimerTriggersOnFailedFetchData) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = \"fun_collection\";\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  test_image_downloader_->set_should_fail(true);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n\n  RunAllTasksUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n  // Lave a little wiggle room.\n  ASSERT_GE(delay, one_hour - base::Minutes(1));\n  ASSERT_LE(delay, one_hour + base::Minutes(1));\n}\n\nTEST_F(WallpaperControllerTest, MigrateCustomWallpaper) {\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  SimulateUserLogin(account_id_1);\n\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n  ClearLogin();\n\n  SimulateUserLogin(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_WallpaperIsntCustom) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kOnline);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_TRUE(client_.get_save_wallpaper_to_drive_fs_account_id().empty());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_AlreadySynced) {\n  WallpaperInfo local_info = InfoWithType(WallpaperType::kCustomized);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  SimulateUserLogin(account_id_1);\n\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER;\n\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout, image,\n                                  false /*preview_mode=*/);\n  RunAllTasksUntilIdle();\n\n  client_.ResetCounts();\n\n  // Should not reupload image if it has already been synced.\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_FALSE(client_.get_save_wallpaper_to_drive_fs_account_id().is_valid());\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_OldLocalInfo) {\n  WallpaperInfo local_info =\n      WallpaperInfo(\"a_url\", WALLPAPER_LAYOUT_CENTER_CROPPED,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  WallpaperInfo synced_info = WallpaperInfo(\n      \"b_url\", WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kCustomized,\n      base::Time::Now().LocalMidnight());\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  SimulateUserLogin(account_id_1);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_FALSE(client_.get_save_wallpaper_to_drive_fs_account_id().is_valid());\n  // This is called by WallpaperController::HandleCustomWallpaperSyncedIn.\n  EXPECT_EQ(client_.get_wallpaper_path_from_drive_fs_account_id(),\n            account_id_1);\n}\n\nTEST_F(WallpaperControllerTest, OnGoogleDriveMounted_NewLocalInfo) {\n  WallpaperInfo local_info = WallpaperInfo(\n      \"a_url\", WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kCustomized,\n      base::Time::Now().LocalMidnight());\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  WallpaperInfo synced_info =\n      WallpaperInfo(\"b_url\", WALLPAPER_LAYOUT_CENTER_CROPPED,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n\n  SimulateUserLogin(account_id_1);\n\n  controller_->SyncLocalAndRemotePrefs(account_id_1);\n  EXPECT_EQ(account_id_1, client_.get_save_wallpaper_to_drive_fs_account_id());\n}\n\nTEST_F(WallpaperControllerTest, SetDailyRefreshCollectionId) {\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kOnline, DayBeforeYesterdayish()));\n\n  std::string collection_id = \"fun_collection\";\n  controller_->SetDailyRefreshCollectionId(account_id_1, collection_id);\n  WallpaperInfo expected = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                            WallpaperType::kDaily, DayBeforeYesterdayish()};\n  expected.collection_id = collection_id;\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  // Type should be `WallpaperType::kDaily` now, and collection_id should be\n  // updated.\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(collection_id,\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\nTEST_F(WallpaperControllerTest, SetDailyRefreshCollectionId_Empty) {\n  std::string collection_id = \"fun_collection\";\n  WallpaperInfo info = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kDaily, DayBeforeYesterdayish()};\n  info.collection_id = collection_id;\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->SetDailyRefreshCollectionId(account_id_1, std::string());\n  WallpaperInfo expected = {std::string(), WALLPAPER_LAYOUT_CENTER,\n                            WallpaperType::kOnline, DayBeforeYesterdayish()};\n  expected.collection_id = collection_id;\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  // Type should be `WallpaperType::kOnline` now, and collection_id should be\n  // `WallpaperType::EMPTY`.\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(std::string(),\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\n// WallpaperType should not change with an empty collection id if the previous\n// WallpaperType isn't |WallpaperType::kDaily|.\nTEST_F(WallpaperControllerTest,\n       SetDailyRefreshCollectionId_Empty_NotTypeDaily) {\n  pref_manager_->SetUserWallpaperInfo(\n      account_id_1,\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish()));\n\n  controller_->SetDailyRefreshCollectionId(account_id_1, std::string());\n  WallpaperInfo expected =\n      WallpaperInfo(std::string(), WALLPAPER_LAYOUT_CENTER,\n                    WallpaperType::kCustomized, DayBeforeYesterdayish());\n\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  EXPECT_EQ(expected, actual);\n  EXPECT_EQ(std::string(),\n            controller_->GetDailyRefreshCollectionId(account_id_1));\n}\n\nTEST_F(WallpaperControllerTest, UpdateWallpaperOnColorModeChanged) {\n  SimulateUserLogin(account_id_1);\n\n  auto run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  controller_->SetOnlineWallpaper(\n      params, base::BindLambdaForTesting([&run_loop](bool success) {\n        EXPECT_TRUE(success);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  pref_manager_->SetUserWallpaperInfo(account_id_1, WallpaperInfo(params));\n  Shell::Get()->session_controller()->GetActivePrefService()->SetBoolean(\n      prefs::kDarkModeEnabled, true);\n  controller_->OnColorModeChanged(true);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n\n  WallpaperInfo expected = WallpaperInfo(OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId, variants));\n  WallpaperInfo actual;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n  EXPECT_EQ(expected, actual);\n}\n\nTEST_F(\n    WallpaperControllerTest,\n    // TODO(crbug.com/9191919): Re-enable this test\n    DISABLED_UpdateDailyWallpaperVariantOnColorModeChanged_RefreshTimerDoesntReset) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n  // Resets the count as user will start with a default image after login.\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/true, kUnitId, variants);\n  const WallpaperInfo info = WallpaperInfo(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  // Set a new daily wallpaper.\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n  base::TimeDelta one_day = base::Days(1);\n  // Leave a little wiggle room, as well as account for the hour fuzzing that\n  // we do.\n  EXPECT_GE(delay, one_day - base::Minutes(1));\n  EXPECT_LE(delay, one_day + base::Minutes(61));\n\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDaily);\n\n  // Fast forward by one hour and attempt a system's color mode change.\n  task_environment()->FastForwardBy(base::Hours(1));\n  Shell::Get()->dark_light_mode_controller()->ToggleColorMode();\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(2, GetWallpaperCount());\n  // Expect the refresh timer doesn't reset.\n  EXPECT_EQ(\n      run_time,\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time());\n\n  WallpaperInfo actual;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual));\n  EXPECT_EQ(info, actual);\n}\n\nTEST_F(WallpaperControllerTest,\n       UpdateWallpaperInfoWithOnlineWallpaperVariants) {\n  SimulateUserLogin(account_id_1);\n\n  // auto run_loop = std::make_unique<base::RunLoop>();\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n\n  pref_manager_->SetUserWallpaperInfo(account_id_1, WallpaperInfo(params));\n  WallpaperInfo expected = WallpaperInfo(params);\n  WallpaperInfo actual;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &actual);\n  EXPECT_EQ(expected, actual);\n}\n\nTEST_F(WallpaperControllerTest, SetOnlineWallpaperIfExists) {\n  SetBypassDecode();\n  gfx::ImageSkia image = CreateImage(640, 480, kWallpaperColor);\n  WallpaperLayout layout = WALLPAPER_LAYOUT_CENTER_CROPPED;\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_UNKNOWN);\n  SimulateUserLogin(account_id_1);\n\n  // Verify that calling |SetOnlineWallpaperIfExists| without providing image\n  // data fails.\n  std::unique_ptr<base::RunLoop> run_loop = std::make_unique<base::RunLoop>();\n  ClearWallpaperCount();\n  const OnlineWallpaperParams& params = OnlineWallpaperParams(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId, layout,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId, variants);\n  controller_->SetOnlineWallpaperIfExists(\n      params, base::BindLambdaForTesting([&run_loop](bool file_exists) {\n        EXPECT_FALSE(file_exists);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(0, GetWallpaperCount());\n\n  // Set an online wallpaper with image data. Verify that the wallpaper is set\n  // successfully.\n  ClearWallpaperCount();\n  controller_->SetOnlineWallpaperFromData(\n      params,\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n  // Verify that the user wallpaper info is updated.\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info = WallpaperInfo(params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n\n  // Change the on-screen wallpaper to a different one. (Otherwise the\n  // subsequent calls will be no-op since we intentionally prevent reloading the\n  // same wallpaper.)\n  ClearWallpaperCount();\n  controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                  CreateImage(640, 480, kWallpaperColor),\n                                  /*preview_mode=*/false);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n\n  // Attempt to set an online wallpaper via |SetOnlineWallpaperIfExists| without\n  // providing the image data. Verify it succeeds this time because\n  // |SetOnlineWallpaperFromData| has saved the file.\n  ClearWallpaperCount();\n  run_loop = std::make_unique<base::RunLoop>();\n  controller_->SetOnlineWallpaperIfExists(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            layout,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants),\n      base::BindLambdaForTesting([&run_loop](bool file_exists) {\n        EXPECT_TRUE(file_exists);\n        run_loop->Quit();\n      }));\n  run_loop->Run();\n  EXPECT_EQ(1, GetWallpaperCount());\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedForDarkLightWallpapers_NotSynced) {\n  SimulateUserLogin(account_id_1);\n  CacheOnlineWallpaper(kDummyUrl);\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // Force local info to not have a unit_id.\n  WallpaperInfo local_info = WallpaperInfo(params);\n  local_info.unit_id = absl::nullopt;\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  const OnlineWallpaperParams& params2 =\n      OnlineWallpaperParams(account_id_1, kAssetId2, GURL(kDummyUrl2),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // synced info tracks dark variant.\n  const WallpaperInfo& synced_info = WallpaperInfo(params2);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(synced_info, actual_info);\n  // Verify the wallpaper is set.\n  EXPECT_EQ(1, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest,\n       HandleWallpaperInfoSyncedForDarkLightWallpapers_AlreadySynced) {\n  SimulateUserLogin(account_id_1);\n  CacheOnlineWallpaper(kDummyUrl);\n  ClearWallpaperCount();\n\n  std::vector<OnlineWallpaperVariant> variants;\n  variants.emplace_back(kAssetId, GURL(kDummyUrl),\n                        backdrop::Image::IMAGE_TYPE_LIGHT_MODE);\n  variants.emplace_back(kAssetId2, GURL(kDummyUrl2),\n                        backdrop::Image::IMAGE_TYPE_DARK_MODE);\n  const OnlineWallpaperParams& params =\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // local info tracks light variant.\n  const WallpaperInfo& local_info = WallpaperInfo(params);\n  pref_manager_->SetLocalWallpaperInfo(account_id_1, local_info);\n\n  const OnlineWallpaperParams& params2 =\n      OnlineWallpaperParams(account_id_1, kAssetId2, GURL(kDummyUrl2),\n                            TestWallpaperControllerClient::kDummyCollectionId,\n                            WALLPAPER_LAYOUT_CENTER_CROPPED,\n                            /*preview_mode=*/false, /*from_user=*/true,\n                            /*daily_refresh_enabled=*/false, kUnitId, variants);\n  // synced info tracks dark variant.\n  const WallpaperInfo& synced_info = WallpaperInfo(params2);\n  pref_manager_->SetSyncedWallpaperInfo(account_id_1, synced_info);\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo actual_info;\n  EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1, &actual_info));\n  EXPECT_EQ(local_info, synced_info);\n  EXPECT_EQ(local_info, actual_info);\n  // Verify the wallpaper is not set again.\n  EXPECT_EQ(0, GetWallpaperCount());\n}\n\nTEST_F(WallpaperControllerTest, WallpaperCustomization_Used) {\n  // Reset to login screen.\n  GetSessionControllerClient()->RequestSignOut();\n\n  // Emulate login screen behavior.\n  controller_->ShowSigninWallpaper();\n  // Let the task queue run so that we run `ShowWallpaperImage()`.\n  task_environment()->RunUntilIdle();\n\n  std::pair<const base::FilePath, const base::FilePath> paths =\n      CreateCustomizationWallpapers();\n  ASSERT_FALSE(paths.first.empty());\n  ASSERT_FALSE(paths.second.empty());\n\n  SetBypassDecode();\n  controller_->SetCustomizedDefaultWallpaperPaths(paths.first, paths.second);\n  task_environment()->RunUntilIdle();\n\n  // Verify that the customized wallpaper is in use.\n  EXPECT_THAT(GetCurrentWallpaperInfo().location,\n              testing::EndsWith(kCustomizationSmallWallpaperName));\n}\n\nTEST_F(WallpaperControllerTest, WallpaperCustomization_UnusedForNonDefault) {\n  SetBypassDecode();\n  SimulateUserLogin(account_id_1);\n\n  // Set wallpaper to something a user may have chose.\n  controller_->SetOnlineWallpaperFromData(\n      OnlineWallpaperParams(account_id_1, kAssetId, GURL(kDummyUrl),\n                            /*collection_id=*/std::string(),\n                            WALLPAPER_LAYOUT_CENTER,\n                            /*preview_mode=*/false, /*from_user=*/false,\n                            /*daily_refresh_enabled=*/false, kUnitId,\n                            /*variants=*/std::vector<OnlineWallpaperVariant>()),\n      /*image_data=*/std::string(),\n      WallpaperController::SetWallpaperCallback());\n  // Let the task queue run so that we run `ShowWallpaperImage()`.\n  task_environment()->RunUntilIdle();\n\n  // Simulate wallpaper customization retrieval completing after login.\n  std::pair<const base::FilePath, const base::FilePath> paths =\n      CreateCustomizationWallpapers();\n  ASSERT_FALSE(paths.first.empty());\n  ASSERT_FALSE(paths.second.empty());\n\n  controller_->SetCustomizedDefaultWallpaperPaths(paths.first, paths.second);\n  task_environment()->RunUntilIdle();\n\n  // Verify that we still use the online wallpaper. i.e. did not switch to\n  // default.\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n}\n\nclass WallpaperControllerGooglePhotosWallpaperTest\n    : public WallpaperControllerTest,\n      public testing::WithParamInterface<bool> {\n public:\n  WallpaperControllerGooglePhotosWallpaperTest() {\n    if (GooglePhotosEnabled()) {\n      scoped_feature_list_.InitWithFeatures(\n          {ash::features::kWallpaperGooglePhotosIntegration}, {});\n    } else {\n      scoped_feature_list_.InitWithFeatures(\n          {}, {ash::features::kWallpaperGooglePhotosIntegration});\n    }\n  }\n\n  WallpaperControllerGooglePhotosWallpaperTest(\n      const WallpaperControllerGooglePhotosWallpaperTest&) = delete;\n  WallpaperControllerGooglePhotosWallpaperTest& operator=(\n      const WallpaperControllerGooglePhotosWallpaperTest&) = delete;\n\n  ~WallpaperControllerGooglePhotosWallpaperTest() override = default;\n\n  bool GooglePhotosEnabled() const { return GetParam(); }\n\n  void WaitForWallpaperCount(int count) {\n    base::RunLoop run_loop;\n    base::RepeatingTimer repeating_timer;\n    repeating_timer.Start(FROM_HERE, base::Milliseconds(10),\n                          base::BindLambdaForTesting([&]() {\n                            if (GetWallpaperCount() >= count) {\n                              repeating_timer.Stop();\n                              run_loop.Quit();\n                            }\n                          }));\n    run_loop.Run();\n  }\n\n private:\n  base::test::ScopedFeatureList scoped_feature_list_;\n};\n\nINSTANTIATE_TEST_SUITE_P(All,\n                         WallpaperControllerGooglePhotosWallpaperTest,\n                         testing::Bool());\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, SetGooglePhotosWallpaper) {\n  bool feature_enabled = GooglePhotosEnabled();\n  SimulateUserLogin(account_id_1);\n\n  // First set the wallpaper to an Online one so we can tell for sure if setting\n  // a Google Photos wallpaper has failed.\n  base::test::TestFuture<bool> online_future;\n  controller_->SetOnlineWallpaper(\n      {account_id_1,\n       kAssetId,\n       GURL(kDummyUrl),\n       TestWallpaperControllerClient::kDummyCollectionId,\n       WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false,\n       /*from_user=*/true,\n       /*daily_refresh_enabled=*/false,\n       kUnitId,\n       {}},\n      online_future.GetCallback());\n  ASSERT_TRUE(online_future.Wait());\n  ASSERT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  // Now attempt setting a Google Photos wallpaper.\n  ClearWallpaperCount();\n  int expected_wallpaper_count = 0;\n  ASSERT_EQ(expected_wallpaper_count, GetWallpaperCount());\n  GooglePhotosWallpaperParams params(account_id_1, kFakeGooglePhotosPhotoId,\n                                     /*daily_refresh_enabled=*/false,\n                                     WallpaperLayout::WALLPAPER_LAYOUT_STRETCH,\n                                     /*preview_mode=*/false, \"dedup_key\");\n\n  controller_->SetGooglePhotosWallpaper(params, base::DoNothing());\n  if (feature_enabled)\n    ++expected_wallpaper_count;\n\n  WaitForWallpaperCount(expected_wallpaper_count);\n\n  EXPECT_EQ(feature_enabled, controller_->GetWallpaperType() ==\n                                 WallpaperType::kOnceGooglePhotos);\n\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(params);\n  EXPECT_EQ(feature_enabled, wallpaper_info == expected_wallpaper_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       SetGooglePhotosWallpaperFails) {\n  SimulateUserLogin(account_id_1);\n\n  // First set the wallpaper to an Online one so we can tell for sure if setting\n  // a Google Photos wallpaper has failed.\n  base::test::TestFuture<bool> online_future;\n  OnlineWallpaperParams online_params(\n      {account_id_1,\n       kAssetId,\n       GURL(kDummyUrl),\n       TestWallpaperControllerClient::kDummyCollectionId,\n       WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false,\n       /*from_user=*/true,\n       /*daily_refresh_enabled=*/false,\n       kUnitId,\n       {}});\n  controller_->SetOnlineWallpaper(online_params, online_future.GetCallback());\n  ASSERT_TRUE(online_future.Wait());\n  ASSERT_EQ(1, GetWallpaperCount());\n  ASSERT_EQ(controller_->GetWallpaperType(), WallpaperType::kOnline);\n\n  // Attempt to set a Google Photos wallpaper with the client set to fail to\n  // fetch the Google Photos photo data.\n  client_.set_fetch_google_photos_photo_fails(true);\n  ClearWallpaperCount();\n  ASSERT_EQ(0, GetWallpaperCount());\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, false,\n       WallpaperLayout::WALLPAPER_LAYOUT_STRETCH, false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_FALSE(google_photos_future.Get());\n  EXPECT_NE(controller_->GetWallpaperType(), WallpaperType::kOnceGooglePhotos);\n\n  WallpaperInfo wallpaper_info;\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &wallpaper_info));\n  WallpaperInfo expected_wallpaper_info(online_params);\n  EXPECT_EQ(wallpaper_info, expected_wallpaper_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       RetryTimerTriggersOnFailedFetchPhotoForStalenessCheck) {\n  using base::Time;\n\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(account_id_1, kFakeGooglePhotosPhotoId,\n                                     /*daily_refresh_enabled=*/false,\n                                     WallpaperLayout::WALLPAPER_LAYOUT_STRETCH,\n                                     /*preview_mode=*/false,\n                                     /*dedup_key=*/absl::nullopt);\n  controller_->SetGooglePhotosWallpaper(params, base::DoNothing());\n  task_environment()->RunUntilIdle();\n\n  Time run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  base::TimeDelta delay = run_time - Time::Now();\n\n  // If the feature is disabled, setting a GooglePhotos wallpaper is a nop.\n  if (GooglePhotosEnabled()) {\n    base::TimeDelta one_day = base::Days(1);\n    // Leave a little wiggle room, as well as account for the hour fuzzing that\n    // we do.\n    EXPECT_GE(delay, one_day - base::Minutes(1));\n    EXPECT_LE(delay, one_day + base::Minutes(61));\n  } else {\n    EXPECT_FALSE(controller_->GetUpdateWallpaperTimerForTesting().IsRunning());\n  }\n\n  client_.set_fetch_google_photos_photo_fails(true);\n\n  // Trigger Google Photos wallpaper cache check.\n  controller_->OnActiveUserSessionChanged(account_id_1);\n\n  run_time =\n      controller_->GetUpdateWallpaperTimerForTesting().desired_run_time();\n  delay = run_time - Time::Now();\n\n  base::TimeDelta one_hour = base::Hours(1);\n\n  // The cache check does not happen when the feature is disabled, since the\n  // local `WallpaperInfo` is rejected.\n  if (GooglePhotosEnabled()) {\n    // Leave a little wiggle room.\n    EXPECT_GE(delay, one_hour - base::Minutes(1));\n    EXPECT_LE(delay, one_hour + base::Minutes(1));\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultForDeletedPhotoOnStalenessCheck) {\n  SimulateUserLogin(account_id_1);\n\n  WallpaperInfo info = {kFakeGooglePhotosPhotoId, WALLPAPER_LAYOUT_CENTER,\n                        WallpaperType::kOnceGooglePhotos,\n                        DayBeforeYesterdayish()};\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  client_.set_google_photo_has_been_deleted(true);\n  // Trigger Google Photos wallpaper cache check.\n  controller_->OnActiveUserSessionChanged(account_id_1);\n  if (GooglePhotosEnabled())\n    WaitForWallpaperCount(1);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            controller_->GetWallpaperType() == WallpaperType::kDefault);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreCachedOnDisk) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH,\n       /*preview_mode=*/false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  base::FilePath saved_wallpaper = online_wallpaper_dir_.GetPath()\n                                       .Append(\"google_photos/\")\n                                       .Append(account_id_1.GetAccountIdKey())\n                                       .Append(kFakeGooglePhotosPhotoId);\n  ASSERT_EQ(GooglePhotosEnabled(), base::PathExists(saved_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreCachedInMemory) {\n  SimulateUserLogin(account_id_1);\n\n  base::FilePath path;\n  EXPECT_FALSE(controller_->GetPathFromCache(account_id_1, &path));\n  gfx::ImageSkia cached_wallpaper;\n  EXPECT_FALSE(\n      controller_->GetWallpaperFromCache(account_id_1, &cached_wallpaper));\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosPhotoId, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH,\n       /*preview_mode=*/false, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  // We store an empty path for Google Photos wallpapers in the in-memory cache\n  // because storing the real path correctly would require updating the cache\n  // after the asynchronous save operation, and we have no use for it anyway.\n  EXPECT_EQ(GooglePhotosEnabled(),\n            controller_->GetPathFromCache(account_id_1, &path));\n  EXPECT_TRUE(path.empty());\n  EXPECT_EQ(GooglePhotosEnabled(), controller_->GetWallpaperFromCache(\n                                       account_id_1, &cached_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       GooglePhotosAreReadFromCache) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n\n  GooglePhotosWallpaperParams params({account_id_1, kFakeGooglePhotosPhotoId,\n                                      /*daily_refresh_enabled=*/false,\n                                      WALLPAPER_LAYOUT_STRETCH,\n                                      /*preview_mode=*/false, \"dedup_key\"});\n  controller_->SetGooglePhotosWallpaper(params,\n                                        google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  // When Google Photos is disabled, the wallpaper will not be in disk cache,\n  // so it will attempt to read from disk, fail to find it, and then reset to\n  // the default wallpaper.\n  const size_t expected_decodes = GooglePhotosEnabled() ? 0 : 1;\n  const WallpaperType expected_type = GooglePhotosEnabled()\n                                          ? WallpaperType::kOnceGooglePhotos\n                                          : WallpaperType::kDefault;\n\n  EXPECT_EQ(expected_decodes, GetDecodeFilePaths().size());\n  EXPECT_EQ(expected_type, controller_->GetWallpaperType());\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, ConfirmPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false, layout,\n       /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  if (GooglePhotosEnabled()) {\n    // Now confirm the preview wallpaper, verify that there's no wallpaper\n    // change because the wallpaper is already shown.\n    ClearWallpaperCount();\n    controller_->ConfirmPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 0);\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n\n    // Verify that the user wallpaper info is now updated to the Google Photos\n    // wallpaper info.\n    WallpaperInfo google_photos_wallpaper_info(\n        photo_id, layout, WallpaperType::kOnceGooglePhotos,\n        base::Time::Now().LocalMidnight());\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, google_photos_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest, CancelPreviewWallpaper) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false,\n       WALLPAPER_LAYOUT_STRETCH, /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  if (GooglePhotosEnabled()) {\n    // Now cancel the preview. Verify the wallpaper changes back to the default\n    // and the user wallpaper info remains unchanged.\n    ClearWallpaperCount();\n    controller_->CancelPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 1);\n    EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n    EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       WallpaperSyncedDuringPreview) {\n  // Verify the user starts with a default wallpaper and the user wallpaper info\n  // is initialized with default values.\n  SimulateUserLogin(account_id_1);\n  ClearWallpaperCount();\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), 1);\n  WallpaperInfo user_wallpaper_info;\n  WallpaperInfo default_wallpaper_info(\n      std::string(), WALLPAPER_LAYOUT_CENTER_CROPPED, WallpaperType::kDefault,\n      base::Time::Now().LocalMidnight());\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n\n  // Simulate opening the wallpaper picker window.\n  std::unique_ptr<aura::Window> wallpaper_picker_window(\n      CreateTestWindow(gfx::Rect(0, 0, 100, 100)));\n  WindowState::Get(wallpaper_picker_window.get())->Activate();\n\n  // Set a Google Photos wallpaper for the user and enable preview. Verify that\n  // the wallpaper is a Google Photos image if the feature is enabled.\n  const WallpaperLayout layout = WALLPAPER_LAYOUT_STRETCH;\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n  ClearWallpaperCount();\n  std::string photo_id = \"foobar\";\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, photo_id, /*daily_refresh_enabled=*/false, layout,\n       /*preview_mode=*/true, \"dedup_key\"},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(google_photos_future.Get(), GooglePhotosEnabled());\n  RunAllTasksUntilIdle();\n  EXPECT_EQ(GetWallpaperCount(), GooglePhotosEnabled() ? 1 : 0);\n  EXPECT_EQ(controller_->GetWallpaperType(),\n            GooglePhotosEnabled() ? WallpaperType::kOnceGooglePhotos\n                                  : WallpaperType::kDefault);\n\n  // Verify that the user wallpaper info remains unchanged during the preview.\n  EXPECT_TRUE(\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &user_wallpaper_info));\n  EXPECT_EQ(user_wallpaper_info, default_wallpaper_info);\n  histogram_tester().ExpectTotalCount(\"Ash.Wallpaper.Preview.Show\",\n                                      GooglePhotosEnabled() ? 1 : 0);\n\n  // Now set a custom wallpaper for the user and disable preview (this happens\n  // if a custom wallpaper set on another device is being synced). Verify\n  // there's no wallpaper change since preview mode shouldn't be interrupted.\n  if (GooglePhotosEnabled()) {\n    gfx::ImageSkia synced_custom_wallpaper =\n        CreateImage(640, 480, kWallpaperColor);\n    ClearWallpaperCount();\n    controller_->SetCustomWallpaper(account_id_1, file_name_1, layout,\n                                    synced_custom_wallpaper,\n                                    /*preview_mode=*/false);\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 0);\n    EXPECT_EQ(controller_->GetWallpaperType(),\n              WallpaperType::kOnceGooglePhotos);\n\n    // However, the user wallpaper info should already be updated to the new\n    // info.\n    WallpaperInfo synced_custom_wallpaper_info(\n        base::FilePath(wallpaper_files_id_1).Append(file_name_1).value(),\n        layout, WallpaperType::kCustomized, base::Time::Now().LocalMidnight());\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n\n    // Now cancel the preview. Verify the synced custom wallpaper is shown\n    // instead of the initial default wallpaper, and the user wallpaper info is\n    // still correct.\n    ClearWallpaperCount();\n    controller_->CancelPreviewWallpaper();\n    RunAllTasksUntilIdle();\n    EXPECT_EQ(GetWallpaperCount(), 1);\n    EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kCustomized);\n    EXPECT_TRUE(pref_manager_->GetUserWallpaperInfo(account_id_1,\n                                                    &user_wallpaper_info));\n    EXPECT_EQ(user_wallpaper_info, synced_custom_wallpaper_info);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       UpdateGooglePhotosDailyRefreshWallpaper) {\n  // The `TestWallpaperControllerClient` sends back the reversed\n  // `collection_id` when asked to fetch a daily photo.\n  std::string expected_photo_id = kFakeGooglePhotosAlbumId;\n  std::reverse(expected_photo_id.begin(), expected_photo_id.end());\n\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo expected_info;\n  bool success =\n      pref_manager_->GetUserWallpaperInfo(account_id_1, &expected_info);\n  EXPECT_EQ(success, GooglePhotosEnabled());\n  if (success) {\n    EXPECT_EQ(expected_photo_id, expected_info.location);\n    EXPECT_EQ(kFakeGooglePhotosAlbumId, expected_info.collection_id);\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyRefreshTimerStartsForDailyGooglePhotos) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n  auto& timer = controller_->GetUpdateWallpaperTimerForTesting();\n  base::TimeDelta run_time =\n      timer.desired_run_time().ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      (base::Time::Now() + base::Days(1)).ToDeltaSinceWindowsEpoch();\n\n  if (GooglePhotosEnabled()) {\n    EXPECT_GE(run_time, update_time - base::Minutes(1));\n    EXPECT_LE(run_time, update_time + base::Minutes(61));\n  } else {\n    EXPECT_FALSE(timer.IsRunning());\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyRefreshRetryTimerStartsOnFailedFetch) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams params(\n      account_id_1, kFakeGooglePhotosAlbumId,\n      /*daily_refresh_enabled=*/true, WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*dedup_key=*/absl::nullopt);\n  WallpaperInfo info(params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n\n  client_.set_fetch_google_photos_photo_fails(true);\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  base::TimeDelta run_time = controller_->GetUpdateWallpaperTimerForTesting()\n                                 .desired_run_time()\n                                 .ToDeltaSinceWindowsEpoch();\n\n  base::TimeDelta update_time =\n      (base::Time::Now() + base::Hours(1)).ToDeltaSinceWindowsEpoch();\n\n  if (GooglePhotosEnabled()) {\n    EXPECT_GE(run_time, update_time - base::Minutes(1));\n    EXPECT_LE(run_time, update_time + base::Minutes(1));\n  } else {\n    EXPECT_FALSE(controller_->GetUpdateWallpaperTimerForTesting().IsRunning());\n  }\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       EmptyDailyGooglePhotosAlbumsDoNothing) {\n  SimulateUserLogin(account_id_1);\n\n  GooglePhotosWallpaperParams daily_google_photos_params(\n      account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n      WALLPAPER_LAYOUT_CENTER_CROPPED, /*preview_mode=*/false,\n      /*dedup_key=*/absl::nullopt);\n  OnlineWallpaperParams online_params(\n      account_id_1, kAssetId, GURL(kDummyUrl),\n      TestWallpaperControllerClient::kDummyCollectionId,\n      WALLPAPER_LAYOUT_CENTER_CROPPED,\n      /*preview_mode=*/false, /*from_user=*/true,\n      /*daily_refresh_enabled=*/false, kUnitId,\n      /*variants=*/std::vector<OnlineWallpaperVariant>());\n\n  WallpaperInfo online_info(online_params);\n  pref_manager_->SetUserWallpaperInfo(account_id_1, online_info);\n\n  client_.set_fetch_google_photos_photo_fails(true);\n  controller_->SetGooglePhotosWallpaper(daily_google_photos_params,\n                                        base::DoNothing());\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo current_info;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(online_info, current_info);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultForDeletedDailyGooglePhotosAlbums) {\n  SimulateUserLogin(account_id_1);\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n       WallpaperLayout::WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false, /*dedup_key=*/absl::nullopt},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  WallpaperInfo current_info;\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            WallpaperType::kDailyGooglePhotos == current_info.type);\n\n  // This makes the test fetch in `client_` return a null photo, but a\n  // successful call, which is the sign for a deleted or empty album.\n  client_.set_google_photo_has_been_deleted(true);\n\n  controller_->UpdateDailyRefreshWallpaperForTesting();\n  RunAllTasksUntilIdle();\n\n  pref_manager_->GetUserWallpaperInfo(account_id_1, &current_info);\n\n  EXPECT_EQ(GooglePhotosEnabled(),\n            WallpaperType::kDefault == current_info.type);\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       DailyGooglePhotosAreCached) {\n  SimulateUserLogin(account_id_1);\n  // The `TestWallpaperControllerClient` sends back the reversed\n  // `collection_id` when asked to fetch a daily photo.\n  std::string expected_photo_id = kFakeGooglePhotosAlbumId;\n  std::reverse(expected_photo_id.begin(), expected_photo_id.end());\n\n  base::test::TestFuture<bool> google_photos_future;\n  controller_->SetGooglePhotosWallpaper(\n      {account_id_1, kFakeGooglePhotosAlbumId, /*daily_refresh_enabled=*/true,\n       WallpaperLayout::WALLPAPER_LAYOUT_CENTER_CROPPED,\n       /*preview_mode=*/false, /*dedup_key=*/absl::nullopt},\n      google_photos_future.GetCallback());\n  EXPECT_EQ(GooglePhotosEnabled(), google_photos_future.Get());\n  RunAllTasksUntilIdle();\n\n  base::FilePath saved_wallpaper = online_wallpaper_dir_.GetPath()\n                                       .Append(\"google_photos/\")\n                                       .Append(account_id_1.GetAccountIdKey())\n                                       .Append(expected_photo_id);\n  ASSERT_EQ(GooglePhotosEnabled(), base::PathExists(saved_wallpaper));\n}\n\nTEST_P(WallpaperControllerGooglePhotosWallpaperTest,\n       ResetToDefaultWhenLoadingInvalidWallpaper) {\n  SimulateUserLogin(account_id_1);\n\n  const WallpaperType type = GooglePhotosEnabled()\n                                 ? WallpaperType::kCount\n                                 : WallpaperType::kOnceGooglePhotos;\n\n  WallpaperInfo info = {kFakeGooglePhotosPhotoId, WALLPAPER_LAYOUT_CENTER, type,\n                        base::Time::Now()};\n  pref_manager_->SetUserWallpaperInfo(account_id_1, info);\n  controller_->ShowUserWallpaper(account_id_1);\n  RunAllTasksUntilIdle();\n\n  EXPECT_EQ(controller_->GetWallpaperType(), WallpaperType::kDefault);\n}\n\n}  // namespace ash\n"
  }
}