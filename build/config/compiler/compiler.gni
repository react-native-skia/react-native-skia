# Copyright 2015 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/chrome_build.gni")
import("//build/config/chromecast_build.gni")
import("//build/config/chromeos/args.gni")
import("//build/config/chromeos/ui_mode.gni")
import("//build/config/compiler/pgo/pgo.gni")
import("//build/config/sanitizers/sanitizers.gni")
import("//build/toolchain/cc_wrapper.gni")
import("//build/toolchain/goma.gni")
import("//build/toolchain/toolchain.gni")
import("//build_overrides/build.gni")

if (is_android) {
  import("//build/config/android/abi.gni")
}
if (current_cpu == "arm" || current_cpu == "arm64") {
  import("//build/config/arm.gni")
}

if (is_apple) {
  import("//build/config/apple/symbols.gni")
}

if (is_ios) {
  import("//build/config/ios/config.gni")
}

declare_args() {
  # Set to true to use the android unwinder V2 implementation.
  use_android_unwinder_v2 = true
}

declare_args() {
  # Set to true to use lld, the LLVM linker.
  # In late bring-up on macOS (see docs/mac_lld.md).
  # Tentatively used on iOS.
  # The default linker everywhere else.
  use_lld = is_clang && current_os != "zos"
}

declare_args() {
  # Default to warnings as errors for default workflow, where we catch
  # warnings with known toolchains. Allow overriding this e.g. for Chromium
  # builds on Linux that could use a different version of the compiler.
  # With GCC, warnings in no-Chromium code are always not treated as errors.
  treat_warnings_as_errors = true

  # How many symbols to include in the build. This affects the performance of
  # the build since the symbols are large and dealing with them is slow.
  #   2 means regular build with symbols.
  #   1 means minimal symbols, usually enough for backtraces only. Symbols with
  # internal linkage (static functions or those in anonymous namespaces) may not
  # appear when using this level.
  #   0 means no symbols.
  #   -1 means auto-set according to debug/release and platform.
  symbol_level = -1

  # Android-only: Strip the debug info of libraries within lib.unstripped to
  # reduce size. As long as symbol_level > 0, this will still allow stacks to be
  # symbolized.
  strip_debug_info = false

  # Compile in such a way as to enable profiling of the generated code. For
  # example, don't omit the frame pointer and leave in symbols.
  enable_profiling = false

  # use_debug_fission: whether to use split DWARF debug info
  # files. This can reduce link time significantly, but is incompatible
  # with some utilities such as icecc and ccache. Requires gold and
  # gcc >= 4.8 or clang.
  # http://gcc.gnu.org/wiki/DebugFission
  #
  # This is a placeholder value indicating that the code below should set
  # the default.  This is necessary to delay the evaluation of the default
  # value expression until after its input values such as use_gold have
  # been set, e.g. by a toolchain_args() block.
  use_debug_fission = "default"

  # Enables support for ThinLTO, which links 3x-10x faster than full LTO. See
  # also http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html
  # Use it by default on official-optimized android and Chrome OS builds, but
  # not ARC or linux-chromeos since it's been seen to not play nicely with
  # Chrome's clang. crbug.com/1033839
  # Disabled in iOS cronet builds since build step cronet_static_complete
  # wants to build a .a file consumable by external clients, and they won't
  # have the same LLVM revisions as us, making bitcode useless to them.
  use_thin_lto =
      is_cfi || (is_clang && is_official_build && chrome_pgo_phase != 1 &&
                 (is_linux || is_win || is_mac ||
                  (is_ios && use_lld && !is_cronet_build) ||
                  (is_android && target_os != "chromeos") ||
                  (is_chromeos && is_chromeos_device)))

  # If true, use Goma for ThinLTO code generation where applicable.
  use_goma_thin_lto = false

  # Whether we're using a sample profile collected on an architecture different
  # than the one we're compiling for.
  #
  # It's currently not possible to collect AFDO profiles on anything but
  # x86{,_64}.
  using_mismatched_sample_profile = current_cpu != "x64" && current_cpu != "x86"

  # Whether an error should be raised on attempts to make debug builds with
  # is_component_build=false. Very large debug symbols can have unwanted side
  # effects so this is enforced by default for chromium.
  forbid_non_component_debug_builds = build_with_chromium

  # Exclude unwind tables by default for official builds as unwinding can be
  # done from stack dumps produced by Crashpad at a later time "offline" in the
  # crash server. Since this increases binary size, we don't recommend including
  # them in shipping builds.
  # For unofficial (e.g. development) builds and non-Chrome branded (e.g. Cronet
  # which doesn't use Crashpad, crbug.com/479283) builds it's useful to be able
  # to unwind at runtime.
  # Include the unwind tables on Android even for official builds, as otherwise
  # the crash dumps generated by Android's debuggerd are largely useless, and
  # having this additional mechanism to understand issues is particularly helpful
  # to WebView.
  exclude_unwind_tables = is_official_build && !is_android

  # Where to redirect clang crash diagnoses
  clang_diagnostic_dir =
      rebase_path("//tools/clang/crashreports", root_build_dir)

  # Mark binaries as compatible with Shadow Stack of Control-flow Enforcement
  # Technology (CET). If Windows version and hardware supports the feature and
  # it's enabled by OS then additional validation of return address will be
  # performed as mitigation against Return-oriented programming (ROP).
  # https://chromium.googlesource.com/chromium/src/+/main/docs/design/sandbox.md#cet-shadow-stack
  enable_cet_shadow_stack = target_cpu == "x64"

  # If true, optimize for size.
  # Default to favoring speed over size for platforms not listed below.
  optimize_for_size =
      !is_high_end_android && (is_android || is_ios || is_fuchsia || is_castos)

  # Set to true to enable using the ML inliner in LLVM. This currently only
  # enables the ML inliner when targeting Android.
  # Currently the ML inliner is only supported on linux hosts
  use_ml_inliner = false  # To enable: host_os == "linux" && is_android
}

assert(!is_cfi || use_thin_lto, "CFI requires ThinLTO")

if (use_thin_lto && is_debug) {
  print("WARNING: ThinLTO (use_thin_lto=true) doesn't work with debug" +
        " (is_debug=true) build.")
}

declare_args() {
  # Whether we should consider the profile we're using to be accurate. Accurate
  # profiles have the benefit of (potentially substantial) binary size
  # reductions, by instructing the compiler to optimize cold and uncovered
  # functions heavily for size. This often comes at the cost of performance.
  sample_profile_is_accurate = optimize_for_size
}

# Determine whether to enable or disable frame pointers, based on the platform
# and build arguments.
# TODO(crbug.com/1052397): Consider changing is_chromeos_ash to is_chromeos after
# lacros-chrome switches to target_os="chromeos".
if (is_chromeos) {
  # ChromeOS generally prefers frame pointers, to support CWP.
  # However, Clang does not currently generate usable frame pointers in ARM
  # 32-bit builds (https://bugs.llvm.org/show_bug.cgi?id=18505) so disable them
  # there to avoid the unnecessary overhead.
  enable_frame_pointers = current_cpu != "arm"
} else if (is_apple || is_linux || is_chromeos) {
  enable_frame_pointers = true
} else if (is_win) {
  # 64-bit Windows ABI doesn't support frame pointers.
  if (current_cpu == "x64") {
    enable_frame_pointers = false
  } else {
    enable_frame_pointers = true
  }
} else if (is_android) {
  enable_frame_pointers =
      enable_profiling ||
      # Ensure that stacks from arm64 crash dumps are usable (crbug.com/391706).
      current_cpu == "arm64" ||
      # For x86 Android, unwind tables are huge without frame pointers
      # (crbug.com/762629). Enabling frame pointers grows the code size slightly
      # but overall shrinks binaries considerably by avoiding huge unwind
      # tables.
      (current_cpu == "x86" && !exclude_unwind_tables && optimize_for_size) ||
      using_sanitizer ||
      # For caller-callee instrumentation version which needs frame pointers to
      # get the caller address.
      use_call_graph
} else if (is_fuchsia) {
  # Fuchsia on arm64 could use shadow call stack for unwinding.
  enable_frame_pointers = current_cpu != "arm64"
} else {
  # Explicitly ask for frame pointers, otherwise stacks may be missing for
  # sanitizer and profiling builds.
  enable_frame_pointers = using_sanitizer || enable_profiling || is_debug
}

# In general assume that if we have frame pointers then we can use them to
# unwind the stack. However, this requires that they are enabled by default for
# most translation units, that they are emitted correctly, and that the
# compiler or platform provides a way to access them.
can_unwind_with_frame_pointers = enable_frame_pointers
if (current_cpu == "arm" && arm_use_thumb) {
  # We cannot currently unwind ARM Thumb frame pointers correctly.
  # See https://bugs.llvm.org/show_bug.cgi?id=18505
  can_unwind_with_frame_pointers = false
} else if (is_win) {
  # Windows 32-bit does provide frame pointers, but the compiler does not
  # provide intrinsics to access them, so we don't use them.
  can_unwind_with_frame_pointers = false
}

assert(!can_unwind_with_frame_pointers || enable_frame_pointers)

# Unwinding with CFI table is only possible on static library builds and
# requried only when frame pointers are not enabled.
can_unwind_with_cfi_table = is_android && !is_component_build &&
                            !enable_frame_pointers && current_cpu == "arm"

# Whether or not cfi table should be enabled on arm.
# TODO(crbug.com/1090409): Replace can_unwind_with_cfi_table with this once
# sampling profiler is enabled on android.
enable_arm_cfi_table = is_android && !is_component_build && current_cpu == "arm"

declare_args() {
  # Whether to use the gold linker from binutils instead of lld or bfd.
  use_gold = !use_lld && !(is_castos &&
                           (current_cpu == "arm" || current_cpu == "mipsel")) &&
             (((is_linux || is_chromeos_lacros) &&
               (current_cpu == "x64" || current_cpu == "x86" ||
                current_cpu == "arm" || current_cpu == "arm64" ||
                current_cpu == "mipsel" || current_cpu == "mips64el")) ||
              (is_android && (current_cpu == "x86" || current_cpu == "x64" ||
                              current_cpu == "arm" || current_cpu == "arm64")))
}

# Use relative paths for debug info. This is important to make the build
# results independent of the checkout and build directory names, which
# in turn is important for goma compile hit rate.
# Setting this to true may make it harder to debug binaries on Linux, see
# https://chromium.googlesource.com/chromium/src/+/main/docs/linux/debugging.md#Source-level-debug-with-fdebug_compilation_dir
# It's not clear if the crash server will correctly handle dSYMs with relative
# paths, so we disable this feature for official benefit. The main benefit is
# deterministic builds to reduce compile times, so this is less relevant for
# official builders.
strip_absolute_paths_from_debug_symbols_default =
    is_android || is_fuchsia || is_nacl || (is_win && use_lld) || is_linux ||
    is_chromeos || (is_apple && !enable_dsyms)

# If the platform uses stripped absolute paths by default, then we don't expose
# it as a configuration option. If this is causing problems, please file a bug.
if (strip_absolute_paths_from_debug_symbols_default) {
  strip_absolute_paths_from_debug_symbols = true
} else {
  declare_args() {
    strip_absolute_paths_from_debug_symbols = false
  }
}

# If it wasn't manually set, then default use_debug_fission to false.
assert(
    use_debug_fission == "default" || use_debug_fission || !use_debug_fission,
    "Invalid use_debug_fission.")
if (use_debug_fission == "default") {
  use_debug_fission = is_debug && !is_android && !is_fuchsia && !is_apple &&
                      !is_win && (use_gold || use_lld) && cc_wrapper == ""
}

# If it wasn't manually set, set to an appropriate default.
assert(symbol_level >= -1 && symbol_level <= 2, "Invalid symbol_level")
if (symbol_level == -1) {
  if (is_android && !is_component_build && !use_debug_fission) {
    # Prefer faster & smaller release builds.
    symbol_level = 1
  } else if (is_chromeos_device) {
    # Use lower symbol level in Simple Chrome build for faster link time.
    # For Simple Chrome, this should take precedence over is_official_build,
    # turned on by --internal.
    if ((target_cpu == "x64" || target_cpu == "x86") && !is_debug) {
      # For release x86/x64 build, specify symbol_level=0 for faster link time.
      # x86/x64 shows backtraces with symbol_level=0 (arm requires
      # symbol_level=1).
      symbol_level = 0
    } else {
      symbol_level = 1
    }
  } else if (using_sanitizer) {
    # Sanitizers need line table info for stack traces. They don't need type
    # info or variable info, so we can leave that out to speed up the build.
    # Sanitizers also require symbols for filename suppressions to work.
    symbol_level = 1
  } else if ((!is_nacl && !is_linux && !is_chromeos && !is_fuchsia &&
              current_os != "aix") || is_debug || is_official_build ||
             is_castos || is_cast_android) {
    # Linux builds slower by having symbols as part of the target binary,
    # whereas Mac and Windows have them separate, so in Release Linux, default
    # them off, but keep them on for Official builds and Chromecast builds.
    symbol_level = 2
  } else {
    symbol_level = 0
  }
}

# Split dwarf works only for symbol_level == 2.
use_debug_fission = use_debug_fission && symbol_level == 2

# Non-component debug builds with symbol_level = 2 are an undesirable (very slow
# build times) and unsupported (some test binaries will fail with > 4 GB PDBs)
# combination. This is only checked when current_toolchain == default_toolchain
# because the is_component_build flag is set to false in various components of
# the build (like nacl) and we don't want to assert on those.
# iOS does not support component builds so add an exception for this platform.
if (forbid_non_component_debug_builds) {
  assert(
      symbol_level != 2 || current_toolchain != default_toolchain ||
          is_component_build || !is_debug || is_ios || use_debug_fission,
      "Can't do non-component debug builds at symbol_level=2 without use_debug_fission=true")
}
